좋아요. \*\*“AI 모델 서버 상태 + 벤치마크/비교/뉴스”\*\*를 하나의 제품으로 설계합니다. 아래는 **IA(정보구조) → 화면 설계 → 데이터/백엔드 설계 → 수집·모니터링 파이프라인 → 구축 스택/운영 계획** 순으로 정리했습니다. (현재 사용 중인 **다크 톤·카드·차트·슬라이드 디테일**은 유지하고, 컴포넌트/레이아웃만 목적에 맞게 확장합니다.)

---

## 1) 정보 구조(IA) & 내비게이션

**상단 헤더**

* 로고 | 메뉴: **Server Status / Benchmark / 모델 비교 / News**
* 전역 요소: 검색(모델/회사/기능), 프로바이더 필터, 지역(POP) 선택, 라이트/다크 토글(기본 다크)

**페이지**

1. **Server Status (기본 홈)**

   * 상단: 필터/정렬(사용률·지연시간·오류율), **Index 탭(기능별: Chat/Code/Vision/Audio/Embedding, 프로바이더별, 파운데이션별)**
   * **Top 3–5 모델**: 대형 카드(상태 게이지, 접속량, 최신 뉴스 1\~2건, 95p 지연/오류율 미니차트)
   * **순위 리스트**: 나머지 모델은 1줄 행(Row)로(아이콘·모델명·회사·Foundation·상태 점/색·핵심지표 2\~3개)
   * **우측 슬라이드 패널(모델 클릭 시)**:
     개요(회사/파운데이션/릴리즈/기능), **실시간 상태(지연/가용성/오류율/스루풋)**, 과거 24h/7d 트렌드 차트, 가격/제한(토큰, TPS), 공식 상태페이지·문서 링크, 관련 뉴스 요약

2. **Benchmark**

   * 상단: “벤치마크가 의미하는 바” 탭형 설명(초보자용 TL;DR + 고급자용 세부)
   * **주요 10개**(예시):

     * **MMLU**(지식·추론), **GSM8K**(산술 추론), **HellaSwag**(상식 추론), **HumanEval/HumanEval+**(코드 생성 정확), **MATH**(고난도 수학), **ARC-C**(과학/추론), **BBH**(빅벤치 하드), **TruthfulQA**(환각·허위 억제), **MT-Bench**(대화품질), **DROP**(독해·추론)
   * 표: 모델 × 벤치마크 점수(정규화/원점수 토글), 버전/데이터 누수 주의, 평가일시
   * 그래프: 레이더/바/시간 추세(모델 버전별 성능 진화)

3. **모델 비교 (최대 4개)**

   * 좌측: 모델 리스트 + 검색 + 필터(회사/기능/파운데이션/릴리즈연도/가격대)
   * 우측: **비교 테이블(열=모델, 행=스펙)**

     * 스펙: 파운데이션/컨텍스트 길이/멀티모달/함수호출/스트리밍/출력토큰 한도/지역·가용존
     * **가격**: 입력/출력 단가(1K 토큰·이미지·오디오), **사용량 구간별 할인**
     * **API**: 엔드포인트/버전/요구 헤더/레이트 리밋/리트라이 가이드
     * **성능**: 주요 벤치마크 순위·점수, 지연시간 p50/p95, 안정성(오류율)
     * **운영**: 상태 페이지, 공지 채널, 릴리즈 노트 링크
   * UX: **핀 고정 행**, **섹션 접기**, **PNG/PDF 내보내기**, **공유용 퍼머링크(?models=… )**

4. **News (자체 제작 기사)**

   * 일반 뉴스 포털 레이아웃(카테고리: 모델/프로바이더/연구/제품/정책/인프라)
   * 카드+목록 혼합, **핵심요약(3줄)**, 원문/소스 표기, 태그(회사/모델/벤치마크)
   * 에디터 전용 CMS(초안→사실검증→승인→게시 워크플로)

---

## 2) 화면 상세 & 컴포넌트 계획

### 공통 스타일 가이드

* **다크 배경 그라디언트 + 카드 + 미니차트**(현재 목업 톤 유지), 둥근 모서리, 글꼴 Inter/pretendard, **슬라이드 패널로 상세 노출**, **리얼타임 인디케이터(녹색 점+“Live”)**
* 상태 색: **초록 Good / 노랑 Degraded / 빨강 Outage / 회색 Unknown**

### Server Status

* **TopCard** (×3\~5):

  * 좌측: 모델 아이콘+명/회사/파운데이션
  * 중앙: **상태 게이지(가용성 %)** + **지연 p95 미니 Sparklines**
  * 우측: 접속량(활성 호출/분) + **뉴스 1\~2개 티커**
* **RankRow** (나머지):

  * \[아이콘] 모델/회사/파운데이션 | 상태 점 | p95 지연 | 오류율 | 호출/분
* **ModelSlideOver**:

  * 탭: Overview / Live / History / Pricing / Docs / News
  * 차트: 15m 실시간(WS), 24h/7d 집계(요약 통계)

### Benchmark

* **BenchmarkCard**: 이름, 한줄 의미, 평가 축, 주의점
* **BenchmarkMatrix**: 모델×벤치마크 표(정렬·필터·정규화 토글)
* **TrendChart**: 특정 모델 버전 성능 변화

### 모델 비교

* **SelectableList**(좌측) + **CompareTable**(우측)
* **SpecRow**: 툴팁으로 정의/주의(예: “컨텍스트 길이=입력 최대 토큰”)
* **ExportBar**: PNG/PDF, 퍼머링크, 다크/라이트 토글(이미지 내보내기용)

### News

* **ArticleCard/Row**, **TopicHeader**, **TagPills**
* **CMS Editor**: 요약/핵심팩트/출처 필수 입력, 플래그(“의견 포함”/“사실만”)

---

## 3) 데이터 모델(핵심 ERD 초안)

**entities**

* `provider`(id, name, url, status\_page\_url, regions\[])
* `model`(id, name, provider\_id, foundation\_model, modalities\[], released\_at, context\_window, capabilities\[], api\_version)
* `pricing`(id, model\_id, tier, input\_per\_1k, output\_per\_1k, image, audio, currency, region\_scope)
* `status_probe`(id, model\_id, region, ts, latency\_p50, latency\_p95, availability, error\_rate, throughput\_rpm)
* `status_incident`(id, provider\_id, started\_at, ended\_at?, severity, title, description, source\_link)
* `benchmark_score`(id, model\_id, suite, score\_raw, score\_norm, eval\_commit, evaluated\_at, note)
* `news_article`(id, title, dek, body, tags\[], sources\[], author, status, published\_at)
* `doc_ref`(id, model\_id, docs\_url, changelog\_url, quickstart\_url)

**인덱스/키 포인트**

* `status_probe (model_id, ts, region)` 시계열 인덱스
* `benchmark_score (suite, evaluated_at)`
* `pricing (model_id, tier)` 유니크

---

## 4) 수집·모니터링 파이프라인

### A. 서버 상태(헬스) 수집

* **다중 POP**에서 **합성 트랜잭션**:

  * (1) **HTTP Health**: 토큰 없는 공개 엔드포인트(공식 Status Page/Docs 핑)
  * (2) **Authorized Ping**: 샘플 프롬프트(“ping”)로 최소 토큰 호출 → **p50/p95 지연·오류율** 측정
  * (3) **TCP/ICMP**(가능 시): 네트워크 레벨 가용성
* **지역(POP)**: 서울/도쿄/싱가포르/프랑크푸르트/버지니아/오리건 최소 6곳
* 스케줄: 30\~60초 주기, 실패 시 지수백오프+재시도 로깅
* **산출 지표**: availability(%), latency p50/p95(ms), error\_rate(%), throughput(rpm)

### B. 벤치마크 데이터

* 공식 리포·오픈 리더보드/논문에서 **소스명+버전+커밋**까지 메타와 함께 저장
* **정규화 로직**: 각 벤치마크별 SOTA 대비 상대점수(0–100), 날짜/프롬프트 정책 명시
* 자동 갱신: 주 1\~2회 + 수동 편집 승인

### C. 뉴스 파이프라인

* **크롤러(Playwright)** → **중복제거(LSH/문장 임베딩)** → **LLM 요약(사실만/중립)** → **사실검증(룰+휴먼 리뷰)** → **CMS 승인** → 게시
* 메타: 원문링크·발행일·작성자·주제태그(모델/벤치마크/회사)

---

## 5) 기술 스택 & 아키텍처

**프론트엔드**

* **Next.js 14(App Router) + TypeScript**
* **Tailwind CSS + shadcn/ui**(카드/드로어/툴팁/탭)
* **TanStack Query**(데이터 패칭·캐시), **Zustand**(UI 상태)
* **Recharts / ECharts**(미니 스파크라인·게이지·트렌드)
* **Socket.IO(Client)** for Live status
* 이미지 내보내기: `html-to-image` 또는 서버 사이드 `puppeteer`(PDF/PNG)

**백엔드**

* **Node.js(Express/Fastify)** 또는 **FastAPI**(선호 스택에 맞춰 1언어로 통일 권장)
* **Workers**: 상태 프로브/크롤링/요약 → 큐 기반 **BullMQ(Redis)** 또는 **Celery(RabbitMQ)**
* DB: **PostgreSQL + Prisma**, 시계열 보간은 **TimescaleDB** 선택지
* 캐시: **Redis**(핫 지표 30\~120초 TTL)
* 스트림/실시간: **Socket.IO(Server)**
* 모니터링: **Prometheus + Grafana**, 에러: **Sentry**
* 배포: **Docker**(+ Compose/Swarm/K8s), **CDN**(정적), **Cron**(GHA/Cloud Scheduler)

**보안/키 관리**

* 모델별 API 키는 **서버 보관**(KMS/환경변수), 키 유출 방지
* 프록시 레이어에서 **레이트 리밋**(IP/사용자), **요청 샘플링 로깅**

---

## 6) API 설계(요약)

**GET /api/status?region=seoul\&sort=usage**
→ `{ models: [{id, name, provider, foundation, status: {availability, p95, error_rate, rpm}, news:[...] }] }`

**GET /api/models/\:id**
→ 상세(스펙/가격/문서/최근상태 시계열)

**GET /api/benchmarks?suites=MMLU,GSM8K**
→ 모델×벤치마크 매트릭스

**GET /api/compare?ids=a,b,c**
→ 4개 이하 모델 스펙/가격/성능 패키지

**GET /api/news?tag=mistral**
→ 기사 목록

**WS /ws/status**
→ 15\~30초 주기 브로드캐스트 `{id, region, p95, availability, rpm}`

---

## 7) 상태 산정 로직(요지)

* **Availability(%)** = 1 - (5m 윈도우 오류요청/총요청)
* **Status 색상**

  * Green: avail ≥ 99.5% & p95 < 1.5s
  * Yellow: 98.0–99.5% or p95 1.5–3.0s
  * Red: <98.0% or p95 ≥ 3.0s
* **Usage(접속량)**: 최근 5m rps/rpm 평균(지역별 가중)

---

## 8) 페이지 레이아웃(배치 스케치)

* **헤더**: 좌 로고 / 우 메뉴(4개) + 검색 + POP 선택
* **Server Status**:

  * 상단 필터 탭 + 정렬 드롭다운
  * 2열 그리드로 **TopCard × 3–5**
  * 하단 **Ranked List**(가상스크롤)
  * **ModelSlideOver**: 화면 우측 480–560px 드로어, 탭과 시계열 차트
* **Benchmark**:

  * 상단: 설명 탭(간략/상세)
  * 중앙: **Matrix 표**(고정 헤더)
  * 하단: 레이더/바 차트(선택 모델만)
* **모델 비교**:

  * 좌: 리스트+검색(고정폭)
  * 우: **비교 표**(섹션별 구분선, 핀 행) + 내보내기 바
* **News**:

  * 상단: 카테고리/태그
  * 본문: 카드형(메인) + 리스트형(서브), 페이지네이션

---

## 9) 구축 단계(로드맵)

**Phase 0 — 스캐폴딩 (1\~2일)**

* Next.js + Tailwind + shadcn/ui 세팅, 전역 테마/레이아웃
* 전역 상태(TanStack Query), 라우팅 4페이지 골격

**Phase 1 — 데이터 스키마 & 베이스 API (3\~5일)**

* Postgres/Prisma 마이그레이션
* `model/provider/pricing/benchmarks/news` CRUD + 목록 API

**Phase 2 — 상태 수집 워커 (5\~7일)**

* POP 3개로 시작(서울·싱가포르·버지니아) 합성 트랜잭션 구현
* Redis 캐시 + 지표 집계 + Socket.IO 실시간 푸시

**Phase 3 — UI 1차 (5\~7일)**

* Server Status: TopCard/RankRow/SlideOver + 라이브 인디케이터
* Benchmark: 10개 카드 + 매트릭스 표
* Compare: 선택 리스트 + 비교 표 + 퍼머링크
* News: 목록/상세(더미 데이터)

**Phase 4 — 뉴스 파이프라인/CMS (5\~7일)**

* 크롤러 → 요약(LLM) → 승인(CMS) → 게시
* 출처/인용/태그 체계

**Phase 5 — 고도화 (지속)**

* POP 6개 확대, 알림(Degraded/Outage Webhook)
* 내보내기(PNG/PDF), 접근성/키보드 내비, 성능 튜닝
* 권한(에디터/관리자)

---

## 10) 품질/운영

* **성능**: 리스트 가상화(react-virtualized), 차트 데이터 다운샘플, 이미지 지연 로딩
* **신뢰성**: 각 프로브에 **샌드박스 키** 분리, 타임아웃/리트라이 정책 명확화
* **법/윤리**: 크롤링 **robots.txt** 준수, 출처 표기, 자동 요약물 사실성 검토
* **오류 가시화**: Sentry + Grafana 대시보드(에러율/지연/가용성)

---

## 11) 초기 데이터 세트(샘플 필드)

```json
{
  "id": "gpt-4.1",
  "provider": "OpenAI",
  "foundation_model": "GPT-4 class",
  "modalities": ["text","image"],
  "capabilities": ["function_calling","streaming"],
  "context_window": 128000,
  "api_version": "2025-06",
  "status": {
    "region": "seoul",
    "availability": 99.92,
    "latency_p95_ms": 980,
    "error_rate": 0.2,
    "rpm": 3400
  },
  "pricing": {
    "tier": "public",
    "input_per_1k": 5.00,
    "output_per_1k": 15.00,
    "currency": "USD"
  }
}
```

---

## 12) 바로 착수 체크리스트

* [ ] 모델/프로바이더 1차 목록 정의(이름·아이콘·문서링크·상태페이지)
* [ ] POP 3개 크레덴셜 준비(테스트 키/네트워크)
* [ ] DB/Prisma 마이그레이션 배포
* [ ] 상태 워커(합성 트랜잭션) 1차 구현 + Redis 캐시
* [ ] Server Status UI(TopCard+RankRow+SlideOver) 1차 완성
* [ ] 벤치마크 10개 설명 문안/출처 정리
* [ ] 비교표 행 항목 확정(스펙/가격/성능/운영)
* [ ] 뉴스 CMS 최소기능(초안→승인→게시)

---


아래는 \*\*프론트 3컴포넌트(TopCard / RankRow / ModelSlideOver)\*\*와 **Prisma 스키마(핵심 ERD)**, 그리고 **Next.js App Router용 API 라우트 스켈레톤**입니다. 현재 스타일(다크·카드·슬라이드·미니차트)을 전제로 **Tailwind + shadcn/ui** 기준으로 작성했습니다.

---

## 0) 타입 공통 (프론트·백 공용)

**`/src/types/model.ts`**

```ts
export type RegionCode = 'seoul' | 'tokyo' | 'singapore' | 'virginia' | 'frankfurt' | 'oregon';

export type StatusBadge = 'good' | 'degraded' | 'outage' | 'unknown';

export interface ModelItem {
  id: string;
  name: string;
  provider: string;
  foundationModel: string;
  iconUrl?: string;
  releasedAt?: string; // ISO
}

export interface LiveStatus {
  modelId: string;
  region: RegionCode;
  availability: number;   // 0~100
  latencyP95Ms: number;
  errorRate: number;      // 0~100
  rpm: number;            // requests per minute
  status: StatusBadge;
  ts: string;             // ISO
}

export interface NewsBrief {
  id: string;
  title: string;
  url: string;
  publishedAt: string;
}

export interface ModelDetail extends ModelItem {
  modalities: string[];
  capabilities: string[];
  contextWindow?: number;
  apiVersion?: string;
  docs?: { docsUrl?: string; changelogUrl?: string; quickstartUrl?: string };
  pricing?: {
    currency: string;
    tiers: Array<{
      tier: string;
      inputPer1k?: number;
      outputPer1k?: number;
      image?: number;
      audio?: number;
      regionScope?: string;
    }>
  };
  recentLive?: LiveStatus[];
  news?: NewsBrief[];
}
```

---

## 1) 프론트 컴포넌트

### 1-1) TopCard (상위 3\~5개용 대형 카드)

**`/src/components/status/TopCard.tsx`**

```tsx
'use client';

import Image from 'next/image';
import { useMemo } from 'react';
import { LiveStatus, ModelItem, NewsBrief } from '@/types/model';
import { cn } from '@/lib/utils';

type Props = {
  model: ModelItem;
  live: LiveStatus;            // 현재 지역 기준 최신 스냅샷
  trend?: number[];            // p95 미니 스파크라인(최근 N포인트)
  news?: NewsBrief[];          // 최신 1~2건
  onClick?: () => void;
};

function statusColor(s: LiveStatus['status']) {
  switch (s) {
    case 'good': return 'bg-emerald-500';
    case 'degraded': return 'bg-amber-500';
    case 'outage': return 'bg-rose-500';
    default: return 'bg-slate-500';
  }
}

export default function TopCard({ model, live, trend = [], news = [], onClick }: Props) {
  const availabilityText = `${live.availability.toFixed(2)}%`;
  const latencyText = `${Math.round(live.latencyP95Ms)} ms`;
  const rpmText = `${live.rpm.toLocaleString()}/m`;

  // 게이지 너비 (가용성)
  const gaugeW = useMemo(() => Math.max(4, Math.min(100, Math.round(live.availability))), [live.availability]);

  return (
    <button
      onClick={onClick}
      className="group relative w-full rounded-2xl border border-white/10 bg-gradient-to-b from-slate-900 to-slate-950 p-5 text-left hover:border-white/20 transition"
    >
      {/* 헤더 */}
      <div className="flex items-center gap-4">
        {model.iconUrl ? (
          <Image src={model.iconUrl} alt={model.name} width={40} height={40} className="rounded-md" />
        ) : (
          <div className="h-10 w-10 rounded-md bg-white/10" />
        )}
        <div className="min-w-0">
          <div className="flex items-center gap-2">
            <h3 className="truncate text-lg font-semibold">{model.name}</h3>
            <span className={cn('inline-block h-2 w-2 rounded-full', statusColor(live.status))} />
          </div>
          <p className="text-sm text-slate-400">
            {model.provider} · {model.foundationModel} · {live.region.toUpperCase()}
          </p>
        </div>
      </div>

      {/* 본문 지표 */}
      <div className="mt-4 grid grid-cols-3 gap-4">
        <div>
          <p className="text-xs text-slate-400">Availability</p>
          <div className="mt-1">
            <div className="h-2 w-full rounded bg-white/10">
              <div className={cn('h-2 rounded', statusColor(live.status))} style={{ width: `${gaugeW}%` }} />
            </div>
            <p className="mt-1 text-sm">{availabilityText}</p>
          </div>
        </div>
        <div>
          <p className="text-xs text-slate-400">p95 Latency</p>
          <p className="mt-2 text-sm">{latencyText}</p>
          {/* 미니 스파크라인 */}
          <svg className="mt-2 h-8 w-full" viewBox="0 0 100 24" preserveAspectRatio="none" aria-hidden>
            {trend.length > 1 && (
              <polyline
                points={trend.map((v, i) => `${(i / (trend.length - 1)) * 100},${24 - (v * 24)}`).join(' ')}
                fill="none"
                stroke="currentColor"
                className="text-slate-300/70"
                strokeWidth={1.5}
              />
            )}
          </svg>
        </div>
        <div>
          <p className="text-xs text-slate-400">Traffic</p>
          <p className="mt-2 text-sm">{rpmText}</p>
          <p className="text-xs text-slate-500">active requests/min</p>
        </div>
      </div>

      {/* 뉴스 티커(최대 2) */}
      {news.length > 0 && (
        <div className="mt-4 border-t border-white/5 pt-3">
          <p className="text-xs text-slate-400 mb-1">Latest</p>
          <ul className="space-y-1">
            {news.slice(0, 2).map(n => (
              <li key={n.id} className="truncate text-sm text-slate-200/90">{n.title}</li>
            ))}
          </ul>
        </div>
      )}
    </button>
  );
}
```

---

### 1-2) RankRow (나머지 순위 행)

**`/src/components/status/RankRow.tsx`**

```tsx
'use client';

import Image from 'next/image';
import { LiveStatus, ModelItem } from '@/types/model';
import { cn } from '@/lib/utils';

type Props = {
  rank: number;
  model: ModelItem;
  live: LiveStatus;
  onClick?: () => void;
};

function statusDot(s: LiveStatus['status']) {
  switch (s) {
    case 'good': return 'bg-emerald-500';
    case 'degraded': return 'bg-amber-500';
    case 'outage': return 'bg-rose-500';
    default: return 'bg-slate-500';
  }
}

export default function RankRow({ rank, model, live, onClick }: Props) {
  return (
    <button
      onClick={onClick}
      className="grid grid-cols-[40px_1fr_100px_100px_120px] items-center gap-3 rounded-xl px-3 py-2 hover:bg-white/5 text-left transition"
    >
      <span className="text-sm text-slate-400">#{rank}</span>

      <div className="flex items-center gap-3 min-w-0">
        {model.iconUrl ? (
          <Image src={model.iconUrl} alt={model.name} width={24} height={24} className="rounded" />
        ) : <div className="h-6 w-6 rounded bg-white/10" />}
        <div className="min-w-0">
          <p className="truncate text-sm font-medium">{model.name}</p>
          <p className="truncate text-xs text-slate-400">
            {model.provider} · {model.foundationModel}
          </p>
        </div>
      </div>

      <div className="flex items-center gap-2">
        <span className={cn('h-2 w-2 rounded-full', statusDot(live.status))} />
        <span className="text-sm">{live.status}</span>
      </div>

      <div className="text-sm">{Math.round(live.latencyP95Ms)} ms</div>
      <div className="text-sm">{(live.errorRate).toFixed(2)}% · {live.rpm.toLocaleString()}/m</div>
    </button>
  );
}
```

---

### 1-3) ModelSlideOver (우측 상세 드로어)

**`/src/components/status/ModelSlideOver.tsx`**

```tsx
'use client';

import { ModelDetail } from '@/types/model';
import { useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'; // shadcn/ui
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';

type Props = {
  open: boolean;
  onOpenChange: (v: boolean) => void;
  data?: ModelDetail;
};

export default function ModelSlideOver({ open, onOpenChange, data }: Props) {
  useEffect(() => {
    // 필요 시 실시간 구독 시작/해제 (Socket.IO 등)
  }, [open, data?.id]);

  if (!data) return null;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[720px] md:max-w-[840px] lg:max-w-[960px] bg-slate-950 border-white/10">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            {data.name}
            <span className="text-sm text-slate-400">· {data.provider} · {data.foundationModel}</span>
          </DialogTitle>
        </DialogHeader>

        <Tabs defaultValue="overview" className="mt-2">
          <TabsList>
            <TabsTrigger value="overview">Overview</TabsTrigger>
            <TabsTrigger value="live">Live</TabsTrigger>
            <TabsTrigger value="history">History</TabsTrigger>
            <TabsTrigger value="pricing">Pricing</TabsTrigger>
            <TabsTrigger value="docs">Docs</TabsTrigger>
            <TabsTrigger value="news">News</TabsTrigger>
          </TabsList>

          <TabsContent value="overview" className="mt-4">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-slate-400 mb-1">Modalities</p>
                <p className="text-sm">{data.modalities?.join(', ') || '-'}</p>
              </div>
              <div>
                <p className="text-xs text-slate-400 mb-1">Capabilities</p>
                <p className="text-sm">{data.capabilities?.join(', ') || '-'}</p>
              </div>
              <div>
                <p className="text-xs text-slate-400 mb-1">Context window</p>
                <p className="text-sm">{data.contextWindow ? `${data.contextWindow.toLocaleString()} tokens` : '-'}</p>
              </div>
              <div>
                <p className="text-xs text-slate-400 mb-1">API Version</p>
                <p className="text-sm">{data.apiVersion || '-'}</p>
              </div>
            </div>
          </TabsContent>

          <TabsContent value="live" className="mt-4">
            {/* 최근 15분/실시간 요약 (스파크라인/수치) */}
            <div className="grid grid-cols-4 gap-4">
              {['Region', 'Avail', 'p95', 'RPM'].map((h, i) => (
                <div key={i} className="rounded-lg border border-white/10 p-3">
                  <p className="text-xs text-slate-400">{h}</p>
                  <p className="mt-1 text-sm">
                    {data.recentLive && data.recentLive[0] ? (
                      h === 'Region' ? data.recentLive[0].region.toUpperCase()
                      : h === 'Avail' ? `${data.recentLive[0].availability.toFixed(2)}%`
                      : h === 'p95' ? `${Math.round(data.recentLive[0].latencyP95Ms)} ms`
                      : `${data.recentLive[0].rpm.toLocaleString()}/m`
                    ) : '-'}
                  </p>
                </div>
              ))}
            </div>
            {/* TODO: 라인 차트 컴포넌트 연결 (Recharts/ECharts) */}
            <div className="mt-4 h-40 rounded-lg border border-white/10" />
          </TabsContent>

          <TabsContent value="history" className="mt-4">
            <div className="h-56 rounded-lg border border-white/10" />
          </TabsContent>

          <TabsContent value="pricing" className="mt-4">
            <div className="rounded-lg border border-white/10">
              <table className="w-full text-sm">
                <thead className="text-slate-400">
                  <tr>
                    <th className="px-3 py-2 text-left">Tier</th>
                    <th className="px-3 py-2 text-right">Input /1K</th>
                    <th className="px-3 py-2 text-right">Output /1K</th>
                    <th className="px-3 py-2 text-right">Image</th>
                    <th className="px-3 py-2 text-right">Audio</th>
                    <th className="px-3 py-2 text-left">Region</th>
                  </tr>
                </thead>
                <tbody>
                  {data.pricing?.tiers?.map((t) => (
                    <tr key={t.tier} className="border-t border-white/5">
                      <td className="px-3 py-2">{t.tier}</td>
                      <td className="px-3 py-2 text-right">{t.inputPer1k ?? '-'}</td>
                      <td className="px-3 py-2 text-right">{t.outputPer1k ?? '-'}</td>
                      <td className="px-3 py-2 text-right">{t.image ?? '-'}</td>
                      <td className="px-3 py-2 text-right">{t.audio ?? '-'}</td>
                      <td className="px-3 py-2">{t.regionScope ?? '-'}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </TabsContent>

          <TabsContent value="docs" className="mt-4">
            <ul className="list-disc pl-6 text-sm">
              {data.docs?.docsUrl && <li><a className="underline" href={data.docs.docsUrl}>Docs</a></li>}
              {data.docs?.changelogUrl && <li><a className="underline" href={data.docs.changelogUrl}>Changelog</a></li>}
              {data.docs?.quickstartUrl && <li><a className="underline" href={data.docs.quickstartUrl}>Quickstart</a></li>}
            </ul>
          </TabsContent>

          <TabsContent value="news" className="mt-4">
            <ul className="space-y-2 text-sm">
              {data.news?.map(n => (
                <li key={n.id} className="truncate">
                  <a className="underline" href={n.url}>{n.title}</a>
                  <span className="ml-2 text-slate-400">{new Date(n.publishedAt).toLocaleDateString()}</span>
                </li>
              )) || <li className="text-slate-400">No articles</li>}
            </ul>
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}
```

> **Note:** `Dialog`, `Tabs`는 shadcn/ui 기준입니다. 프로젝트에 shadcn 설치 및 `ui/dialog`, `ui/tabs` 경로 맞춰주세요.

---

## 2) Prisma 스키마

**`/prisma/schema.prisma`**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Severity {
  INFO
  MINOR
  MAJOR
  CRITICAL
}

enum RegionCode {
  seoul
  tokyo
  singapore
  virginia
  frankfurt
  oregon
}

model Provider {
  id             String   @id @default(cuid())
  name           String   @unique
  url            String?
  statusPageUrl  String?
  regions        String[] // 지원 리전 문자열 리스트

  models         Model[]
  incidents      StatusIncident[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Model {
  id               String   @id @default(cuid())
  name             String
  providerId       String
  provider         Provider  @relation(fields: [providerId], references: [id])
  foundationModel  String
  releasedAt       DateTime?
  modalities       String[]  // ["text","image","audio","video","embeddings"]
  capabilities     String[]  // ["function_calling","streaming",...]
  contextWindow    Int?
  apiVersion       String?

  docs             DocRef?
  pricing          Pricing[]
  scores           BenchmarkScore[]
  probes           StatusProbe[]
  news             NewsArticle[] @relation("ModelNews")

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([name])
  @@index([providerId])
}

model Pricing {
  id           String  @id @default(cuid())
  modelId      String
  model        Model   @relation(fields: [modelId], references: [id])
  tier         String  // "public","enterprise","free","promo"
  currency     String  // "USD"
  inputPer1k   Float?
  outputPer1k  Float?
  image        Float?
  audio        Float?
  regionScope  String? // "global","us-only", etc.

  @@unique([modelId, tier])
}

model DocRef {
  id            String  @id @default(cuid())
  modelId       String  @unique
  model         Model   @relation(fields: [modelId], references: [id])
  docsUrl       String?
  changelogUrl  String?
  quickstartUrl String?
}

model StatusProbe {
  id           String     @id @default(cuid())
  modelId      String
  model        Model      @relation(fields: [modelId], references: [id])
  region       RegionCode
  ts           DateTime   @default(now())
  latencyP50   Int?
  latencyP95   Int?
  availability Float?     // 0~100
  errorRate    Float?     // 0~100
  rpm          Int?

  @@index([modelId, region, ts])
}

model StatusIncident {
  id          String    @id @default(cuid())
  providerId  String
  provider    Provider  @relation(fields: [providerId], references: [id])
  severity    Severity
  title       String
  description String?
  startedAt   DateTime
  endedAt     DateTime?

  @@index([providerId, startedAt])
}

model BenchmarkScore {
  id           String   @id @default(cuid())
  modelId      String
  model        Model    @relation(fields: [modelId], references: [id])
  suite        String   // "MMLU","GSM8K",...
  scoreRaw     Float?
  scoreNorm    Float?
  evalCommit   String?
  evaluatedAt  DateTime
  note         String?

  @@index([suite, evaluatedAt])
  @@index([modelId, suite])
}

model NewsArticle {
  id           String    @id @default(cuid())
  title        String
  dek          String?
  body         String?
  tags         String[]
  sources      String[]
  author       String?
  status       String    // "draft","review","published"
  publishedAt  DateTime?

  // 모델 태깅(선택)
  models       Model[]   @relation("ModelNews")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([status, publishedAt])
}
```

---

## 3) Next.js API 라우트 (App Router)

### 3-1) 목록(상태) API — `/app/api/status/route.ts`

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/server/prisma'; // prisma client 래퍼
import { RegionCode } from '@prisma/client';

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const region = (searchParams.get('region') || 'seoul') as RegionCode;
  const limitTop = Number(searchParams.get('top') || 5);

  // 최근 5분 내 최신 스냅샷(모델별 region 최신 ts)
  const models = await prisma.model.findMany({
    include: {
      provider: true,
      probes: {
        where: { region },
        orderBy: { ts: 'desc' },
        take: 1
      },
      news: { take: 2, where: { status: 'published' }, orderBy: { publishedAt: 'desc' } }
    }
  });

  // 사용량(rpm) 기준 정렬
  const withLive = models.map(m => {
    const probe = m.probes[0];
    const status =
      !probe ? 'unknown'
      : (probe.availability ?? 0) >= 99.5 && (probe.latencyP95 ?? 9999) < 1500 ? 'good'
      : (probe.availability ?? 0) >= 98.0 && (probe.latencyP95 ?? 0) < 3000 ? 'degraded'
      : 'outage';

    return {
      id: m.id,
      name: m.name,
      provider: m.provider.name,
      foundationModel: m.foundationModel,
      live: probe ? {
        modelId: m.id,
        region,
        availability: probe.availability ?? 0,
        latencyP95Ms: probe.latencyP95 ?? 0,
        errorRate: probe.errorRate ?? 0,
        rpm: probe.rpm ?? 0,
        status,
        ts: probe.ts.toISOString()
      } : undefined,
      news: m.news.map(n => ({
        id: n.id, title: n.title, url: '#', publishedAt: n.publishedAt?.toISOString() ?? ''
      }))
    };
  });

  const sorted = withLive.sort((a, b) => (b.live?.rpm ?? 0) - (a.live?.rpm ?? 0));
  const top = sorted.slice(0, limitTop);
  const rest = sorted.slice(limitTop);

  return NextResponse.json({ top, rest });
}
```

### 3-2) 상세 API — `/app/api/models/[id]/route.ts`

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/server/prisma';

type Params = { params: { id: string } };

export async function GET(_req: Request, { params }: Params) {
  const m = await prisma.model.findUnique({
    where: { id: params.id },
    include: {
      provider: true,
      pricing: true,
      docs: true,
      probes: {
        orderBy: { ts: 'desc' },
        take: 60 // 최근 60포인트(예: 1~5분 간격)
      },
      news: { where: { status: 'published' }, orderBy: { publishedAt: 'desc' }, take: 10 }
    }
  });

  if (!m) return NextResponse.json({ error: 'not found' }, { status: 404 });

  return NextResponse.json({
    id: m.id,
    name: m.name,
    provider: m.provider.name,
    foundationModel: m.foundationModel,
    modalities: m.modalities,
    capabilities: m.capabilities,
    contextWindow: m.contextWindow,
    apiVersion: m.apiVersion,
    pricing: {
      currency: m.pricing[0]?.currency ?? 'USD',
      tiers: m.pricing.map(p => ({
        tier: p.tier,
        inputPer1k: p.inputPer1k ?? undefined,
        outputPer1k: p.outputPer1k ?? undefined,
        image: p.image ?? undefined,
        audio: p.audio ?? undefined,
        regionScope: p.regionScope ?? undefined
      }))
    },
    docs: {
      docsUrl: m.docs?.docsUrl,
      changelogUrl: m.docs?.changelogUrl,
      quickstartUrl: m.docs?.quickstartUrl
    },
    recentLive: m.probes.map(p => ({
      modelId: m.id,
      region: p.region,
      availability: p.availability ?? 0,
      latencyP95Ms: p.latencyP95 ?? 0,
      errorRate: p.errorRate ?? 0,
      rpm: p.rpm ?? 0,
      status: 'unknown' as const, // 프론트에서 색 로직 재사용 가능
      ts: p.ts.toISOString()
    })),
    news: m.news.map(n => ({
      id: n.id,
      title: n.title,
      url: '#',
      publishedAt: n.publishedAt?.toISOString() ?? ''
    }))
  });
}
```

---

## 4) 간단 페이지 접속 예시 (Server Status 첫 화면)

**`/app/server-status/page.tsx`**

```tsx
import TopCard from '@/components/status/TopCard';
import RankRow from '@/components/status/RankRow';
import ModelSlideOver from '@/components/status/ModelSlideOver';
import { Suspense, useEffect, useState } from 'react';

async function fetchStatus(region = 'seoul') {
  const res = await fetch(`/api/status?region=${region}`, { cache: 'no-store' });
  return res.json() as Promise<{ top: any[]; rest: any[] }>;
}

export default function Page() {
  const [data, setData] = useState<{ top: any[]; rest: any[] }>({ top: [], rest: [] });
  const [open, setOpen] = useState(false);
  const [detail, setDetail] = useState<any>(null);

  useEffect(() => {
    fetchStatus().then(setData);
  }, []);

  async function openDetail(id: string) {
    const res = await fetch(`/api/models/${id}`, { cache: 'no-store' });
    const json = await res.json();
    setDetail(json);
    setOpen(true);
  }

  return (
    <div className="p-6 space-y-6">
      {/* Top 3~5 */}
      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
        {data.top.map((m) => (
          <TopCard
            key={m.id}
            model={m}
            live={m.live}
            trend={[0.2, 0.4, 0.25, 0.5, 0.3, 0.6]} // TODO: API 연결
            news={m.news}
            onClick={() => openDetail(m.id)}
          />
        ))}
      </div>

      {/* Ranked list */}
      <div className="rounded-2xl border border-white/10">
        {data.rest.map((m: any, idx: number) => (
          <RankRow
            key={m.id}
            rank={idx + 1 + data.top.length}
            model={m}
            live={m.live}
            onClick={() => openDetail(m.id)}
          />
        ))}
      </div>

      <ModelSlideOver open={open} onOpenChange={setOpen} data={detail} />
    </div>
  );
}
```

---

## 5) Prisma Client & 유틸

**`/src/server/prisma.ts`**

```ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: ['error', 'warn'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

**`/src/lib/utils.ts`** (shadcn 기본)

```ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

---

① shadcn 설치/구성, ② Prisma seed 스크립트, ③ Recharts 라인차트 컴포넌트, ④ Socket.IO 서버·클라이언트 예제를 바로 붙여 쓸 수 있게 정리한 것입니다. (Next.js App Router + Tailwind + shadcn/ui + Prisma/Postgres 가정)

① shadcn 설치 & 구성
bash
복사
편집
# 1) 설치
pnpm dlx shadcn@latest init        # 또는 npx
# 질문: Tailwind/TS/Dir 등 프로젝트에 맞게 선택

# 2) 필요한 컴포넌트 추가 (슬라이드/탭/버튼/입력/테이블/툴팁 등)
pnpm dlx shadcn@latest add dialog tabs button input table tooltip badge separator card dropdown-menu skeleton
@/components/ui/* 경로로 생성됩니다.

Tailwind 설정(tailwind.config.ts)에 shadcn preset/경로 포함되어야 합니다.

② Prisma Seed 스크립트
2-1) 준비
bash
복사
편집
pnpm add -D tsx
package.json

json
복사
편집
{
  "scripts": {
    "db:migrate": "prisma migrate dev",
    "db:seed": "tsx prisma/seed.ts"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  }
}
2-2) 샘플 Seed
prisma/seed.ts

ts
복사
편집
import { PrismaClient, RegionCode, Severity } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // === Providers ===
  const openai = await prisma.provider.upsert({
    where: { name: 'OpenAI' },
    update: {},
    create: {
      name: 'OpenAI',
      url: 'https://openai.com',
      statusPageUrl: 'https://status.openai.com',
      regions: ['virginia', 'oregon', 'frankfurt', 'singapore', 'tokyo', 'seoul']
    }
  });

  const anthropic = await prisma.provider.upsert({
    where: { name: 'Anthropic' },
    update: {},
    create: {
      name: 'Anthropic',
      url: 'https://www.anthropic.com',
      statusPageUrl: 'https://status.anthropic.com',
      regions: ['virginia', 'frankfurt', 'singapore']
    }
  });

  // === Models ===
  const gpt41 = await prisma.model.upsert({
    where: { id: 'gpt-4.1-demo' },
    update: {},
    create: {
      id: 'gpt-4.1-demo',
      name: 'GPT-4.1',
      providerId: openai.id,
      foundationModel: 'GPT-4 class',
      modalities: ['text','image'],
      capabilities: ['function_calling','streaming'],
      contextWindow: 128000,
      apiVersion: '2025-06'
    }
  });

  const sonnet = await prisma.model.upsert({
    where: { id: 'claude-3.7-sonnet' },
    update: {},
    create: {
      id: 'claude-3.7-sonnet',
      name: 'Claude 3.7 Sonnet',
      providerId: anthropic.id,
      foundationModel: 'Claude 3.x',
      modalities: ['text','image'],
      capabilities: ['tool_use','streaming'],
      contextWindow: 200000,
      apiVersion: '2025-05'
    }
  });

  // === Docs ===
  await prisma.docRef.upsert({
    where: { modelId: gpt41.id },
    update: {},
    create: {
      modelId: gpt41.id,
      docsUrl: 'https://platform.openai.com/docs',
      changelogUrl: 'https://platform.openai.com/docs/changelog',
      quickstartUrl: 'https://platform.openai.com/docs/quickstart'
    }
  });

  await prisma.docRef.upsert({
    where: { modelId: sonnet.id },
    update: {},
    create: {
      modelId: sonnet.id,
      docsUrl: 'https://docs.anthropic.com',
      changelogUrl: 'https://docs.anthropic.com/en/release-notes',
      quickstartUrl: 'https://docs.anthropic.com/en/api/getting-started'
    }
  });

  // === Pricing ===
  await prisma.pricing.upsert({
    where: { modelId_tier: { modelId: gpt41.id, tier: 'public' } },
    update: {},
    create: { modelId: gpt41.id, tier: 'public', currency: 'USD', inputPer1k: 5.0, outputPer1k: 15.0, regionScope: 'global' }
  });
  await prisma.pricing.upsert({
    where: { modelId_tier: { modelId: sonnet.id, tier: 'public' } },
    update: {},
    create: { modelId: sonnet.id, tier: 'public', currency: 'USD', inputPer1k: 3.0, outputPer1k: 15.0, regionScope: 'global' }
  });

  // === Benchmarks ===
  const now = new Date();
  await prisma.benchmarkScore.createMany({
    data: [
      { modelId: gpt41.id, suite: 'MMLU', scoreRaw: 0.89, scoreNorm: 89, evaluatedAt: now },
      { modelId: gpt41.id, suite: 'GSM8K', scoreRaw: 0.95, scoreNorm: 95, evaluatedAt: now },
      { modelId: sonnet.id, suite: 'MMLU', scoreRaw: 0.90, scoreNorm: 90, evaluatedAt: now },
      { modelId: sonnet.id, suite: 'GSM8K', scoreRaw: 0.96, scoreNorm: 96, evaluatedAt: now },
    ]
  });

  // === Probes (최근 시계열 12포인트 예시) ===
  const regions: RegionCode[] = ['seoul','virginia'];
  for (const region of regions) {
    for (let i = 0; i < 12; i++) {
      const ts = new Date(Date.now() - (11 - i) * 60_000);
      await prisma.statusProbe.createMany({
        data: [
          {
            modelId: gpt41.id,
            region,
            ts,
            latencyP50: 550 + Math.round(Math.random()*80),
            latencyP95: 950 + Math.round(Math.random()*150),
            availability: 99.8,
            errorRate: Math.random() < 0.1 ? 0.5 : 0.1,
            rpm: 3200 + Math.round(Math.random()*400),
          },
          {
            modelId: sonnet.id,
            region,
            ts,
            latencyP50: 500 + Math.round(Math.random()*70),
            latencyP95: 900 + Math.round(Math.random()*140),
            availability: 99.9,
            errorRate: Math.random() < 0.08 ? 0.4 : 0.08,
            rpm: 2800 + Math.round(Math.random()*350),
          }
        ]
      });
    }
  }

  // === Incidents ===
  await prisma.statusIncident.create({
    data: {
      providerId: openai.id,
      severity: Severity.MINOR,
      title: 'Intermittent elevated latency (Virginia)',
      description: 'Networking congestion in us-east.',
      startedAt: new Date(Date.now() - 2*60*60*1000),
      endedAt: null
    }
  });

  // === News ===
  const article = await prisma.newsArticle.create({
    data: {
      title: 'GPT-4.1 latency improvements deployed',
      dek: 'p95 latency down ~12% in APAC.',
      body: '…',
      tags: ['OpenAI','GPT-4.1','latency'],
      sources: ['https://status.openai.com'],
      author: 'editor',
      status: 'published',
      publishedAt: new Date()
    }
  });
  await prisma.model.update({
    where: { id: gpt41.id },
    data: { news: { connect: { id: article.id } } }
  });

  console.log('✅ Seed complete');
}

main().catch(e => {
  console.error(e);
  process.exit(1);
}).finally(async () => {
  await prisma.$disconnect();
});
실행: pnpm db:migrate && pnpm db:seed

③ Recharts 라인차트 컴포넌트
3-1) 차트 컴포넌트
/src/components/charts/LatencyLine.tsx

tsx
복사
편집
'use client';

import { ResponsiveContainer, LineChart, Line, XAxis, YAxis, Tooltip, CartesianGrid } from 'recharts';

type Point = { ts: string; p95: number; rpm?: number; avail?: number };

export default function LatencyLine({ data }: { data: Point[] }) {
  return (
    <div className="h-48 w-full">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={data}>
          <CartesianGrid strokeOpacity={0.1} vertical={false} />
          <XAxis
            dataKey="ts"
            tickFormatter={(v) => new Date(v).toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit' })}
            minTickGap={24}
          />
          <YAxis
            dataKey="p95"
            tickFormatter={(v) => `${Math.round(v)}ms`}
            width={60}
          />
          <Tooltip
            formatter={(v: number, n) => n === 'p95' ? `${Math.round(v)} ms` : v}
            labelFormatter={(l) => new Date(l).toLocaleString()}
          />
          <Line type="monotone" dataKey="p95" dot={false} strokeWidth={2} />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}
3-2) ModelSlideOver에 연결
ModelSlideOver.tsx의 live/history 부분의 placeholder를 아래처럼 교체:

tsx
복사
편집
// 상단 import
import LatencyLine from '@/components/charts/LatencyLine';

// ... TabsContent value="live"
<TabsContent value="live" className="mt-4">
  {/* ... 기존 KPI 카드 유지 */}
  <LatencyLine
    data={(data.recentLive ?? [])
      .slice() // 역순 정렬(오래→최근) 보장
      .reverse()
      .map(p => ({ ts: p.ts, p95: p.latencyP95Ms, rpm: p.rpm, avail: p.availability }))}
  />
</TabsContent>

// history 탭도 동일하게 필요 시 최근 24h 데이터 바인딩
④ Socket.IO 서버/클라이언트
권장: Next.js와 별도로 경량 실시간 게이트웨이를 독립 프로세스로 운영(빌드·스케일 분리). 아래는 포트 4001에서 동작하는 예시입니다.

4-1) 서버 (독립 프로세스)
server/realtime.ts

ts
복사
편집
import http from 'http';
import { Server } from 'socket.io';

const PORT = Number(process.env.RT_PORT || 4001);
const server = http.createServer();
const io = new Server(server, {
  cors: { origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'] }
});

type StatusUpdate = {
  id: string;           // model id
  region: string;
  availability: number;
  latencyP95Ms: number;
  errorRate: number;
  rpm: number;
  ts: string;
};

io.on('connection', (socket) => {
  console.log('client connected', socket.id);
});

server.listen(PORT, () => {
  console.log(`✅ Realtime gateway on :${PORT}`);
});

// --- Demo ticker (실서비스에서는 워커/DB에서 pull 또는 Redis Pub/Sub 구독) ---
const demoModels = ['gpt-4.1-demo', 'claude-3.7-sonnet'];
setInterval(() => {
  const payload: StatusUpdate[] = demoModels.map((id) => ({
    id,
    region: 'seoul',
    availability: 99.7 + Math.random() * 0.2,
    latencyP95Ms: 850 + Math.random() * 250,
    errorRate: Math.random() * 0.6,
    rpm: 2500 + Math.round(Math.random()*800),
    ts: new Date().toISOString()
  }));
  io.emit('status:update', payload);
}, 15_000);
실행: ts-node server/realtime.ts 또는 tsx server/realtime.ts

프로덕션: PM2/Docker로 서비스화 권장.

(옵션) Dockerfile 예시

dockerfile
복사
편집
FROM node:20-alpine
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm i -g pnpm && pnpm i --frozen-lockfile
COPY server ./server
CMD ["pnpm","exec","tsx","server/realtime.ts"]
4-2) 클라이언트 훅
/src/hooks/useStatusSocket.ts

ts
복사
편집
'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { io, Socket } from 'socket.io-client';

type Update = {
  id: string;
  region: string;
  availability: number;
  latencyP95Ms: number;
  errorRate: number;
  rpm: number;
  ts: string;
};

export function useStatusSocket(url = process.env.NEXT_PUBLIC_RT_URL || 'http://localhost:4001') {
  const socketRef = useRef<Socket | null>(null);
  const [latest, setLatest] = useState<Record<string, Update>>({});

  useEffect(() => {
    const s = io(url, { transports: ['websocket'] });
    socketRef.current = s;

    s.on('connect', () => {
      // console.log('connected', s.id);
    });

    s.on('status:update', (payload: Update[]) => {
      setLatest(prev => {
        const next = { ...prev };
        for (const u of payload) next[u.id] = u;
        return next;
      });
    });

    return () => { s.disconnect(); };
  }, [url]);

  const get = (modelId: string) => latest[modelId];

  return useMemo(() => ({ latest, get }), [latest]);
}
4-3) Server Status 페이지에 반영
/app/server-status/page.tsx 의 목록 렌더에서 실시간 값을 merge:

tsx
복사
편집
import { useStatusSocket } from '@/hooks/useStatusSocket';

// ...
const { latest, get } = useStatusSocket();

{/* Top */}
{data.top.map((m) => {
  const liveOverride = get(m.id);
  const live = liveOverride ? {
    ...m.live,
    availability: liveOverride.availability,
    latencyP95Ms: liveOverride.latencyP95Ms,
    errorRate: liveOverride.errorRate,
    rpm: liveOverride.rpm,
    ts: liveOverride.ts
  } : m.live;

  return (
    <TopCard
      key={m.id}
      model={m}
      live={live}
      trend={[0.2,0.4,0.25,0.5,0.3,0.6]}
      news={m.news}
      onClick={() => openDetail(m.id)}
    />
  );
})}

// Rest rows도 동일하게 liveOverride 병합
실서비스에선 워커 → DB/Redis → Realtime 게이트웨이(Socket.IO) 흐름을 구성하고, 게이트웨이는 DB를 직접 읽지 않고 Pub/Sub(Redis)만 구독하도록 분리하면 안정적입니다.



① Redis Pub/Sub 실시간 파이프라인
1) 메시지 스키마 & 채널
ts
복사
편집
// /server/realtime/types.ts
export type StatusUpdate = {
  id: string;            // model id
  region: 'seoul'|'tokyo'|'singapore'|'virginia'|'frankfurt'|'oregon';
  availability: number;  // 0~100
  latencyP95Ms: number;
  errorRate: number;     // 0~100
  rpm: number;
  ts: string;            // ISO
};

export const CHANNEL = 'status:update:v1';
2) 워커(측정 → Redis Publish)
실제 운영에선 합성 트랜잭션/프로브가 수집한 결과를 DB에 쓰고, 동시에 Pub 한다고 가정.

ts
복사
편집
// /server/worker/publisher.ts
import Redis from 'ioredis';
import { CHANNEL, StatusUpdate } from '../realtime/types';

const redis = new Redis(process.env.REDIS_URL!);

/** 측정 결과를 퍼블리시 */
export async function publishStatus(updates: StatusUpdate[]) {
  await redis.publish(CHANNEL, JSON.stringify({ updates }));
}

/** 데모 타이커(실측치 대신 샘플) */
export function startDemoTicker() {
  const models = ['gpt-4.1-demo', 'claude-3.7-sonnet'];
  setInterval(async () => {
    const payload: StatusUpdate[] = models.map((id) => ({
      id,
      region: 'seoul',
      availability: 99.7 + Math.random() * 0.2,
      latencyP95Ms: 850 + Math.random() * 250,
      errorRate: Math.random() * 0.6,
      rpm: 2500 + Math.round(Math.random() * 800),
      ts: new Date().toISOString()
    }));
    await publishStatus(payload);
  }, 15000);
}

if (require.main === module) {
  if (!process.env.REDIS_URL) throw new Error('REDIS_URL missing');
  console.log('✅ Worker publisher started');
  startDemoTicker();
}
3) 게이트웨이(Socket.IO) (Redis Subscribe → WebSocket Broadcast)
게이트웨이는 DB를 직접 읽지 않고 오로지 Pub/Sub만 구독하도록 분리.

ts
복사
편집
// /server/realtime/gateway.ts
import http from 'http';
import { Server } from 'socket.io';
import Redis from 'ioredis';
import { CHANNEL, StatusUpdate } from './types';

const PORT = Number(process.env.RT_PORT || 4001);
const CORS = process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'];

const server = http.createServer();
const io = new Server(server, { cors: { origin: CORS } });

const sub = new Redis(process.env.REDIS_URL!);

io.on('connection', (socket) => {
  // console.log('WS client', socket.id);
});

sub.subscribe(CHANNEL, (err) => {
  if (err) throw err;
  console.log(`🛰️  Subscribed ${CHANNEL}`);
});

sub.on('message', (channel, message) => {
  if (channel !== CHANNEL) return;
  try {
    const { updates } = JSON.parse(message) as { updates: StatusUpdate[] };
    io.emit('status:update', updates);
  } catch (e) {
    console.error('Bad message', e);
  }
});

server.listen(PORT, () => {
  console.log(`✅ Realtime gateway on :${PORT}`);
});
4) 환경 변수 & Docker Compose
yaml
복사
편집
# docker-compose.yml (발췌)
version: "3.9"
services:
  redis:
    image: redis:7-alpine
    ports: [ "6379:6379" ]

  gateway:
    build: .
    command: ["pnpm","exec","tsx","server/realtime/gateway.ts"]
    environment:
      REDIS_URL: redis://redis:6379
      RT_PORT: "4001"
      CORS_ORIGIN: "http://localhost:3000"
    ports: [ "4001:4001" ]
    depends_on: [ redis ]

  worker:
    build: .
    command: ["pnpm","exec","tsx","server/worker/publisher.ts"]
    environment:
      REDIS_URL: redis://redis:6379
    depends_on: [ redis ]
프론트 엔드에서는 이전에 제공한 useStatusSocket 훅 그대로 사용(서버 URL만 환경변수로).

② Recharts 멀티축(지연/p95·가용성·RPM)
목표: p95(ms), Availability(%), RPM(요청량)을 각기 다른 축으로 한 그래프에 표시 + 범례 토글.

tsx
복사
편집
// /src/components/charts/MultiAxisStatus.tsx
'use client';

import {
  ResponsiveContainer, LineChart, Line, XAxis, YAxis, Tooltip,
  CartesianGrid, Legend
} from 'recharts';

type Point = {
  ts: string;        // ISO
  p95: number;       // ms
  avail: number;     // %
  rpm: number;       // per minute
};

export default function MultiAxisStatus({ data }: { data: Point[] }) {
  return (
    <div className="h-72 w-full">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={data}>
          <CartesianGrid strokeOpacity={0.1} vertical={false} />
          <XAxis
            dataKey="ts"
            tickFormatter={(v) =>
              new Date(v).toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit' })
            }
            minTickGap={24}
          />
          {/* Left Y: p95(ms) */}
          <YAxis
            yAxisId="ms"
            tickFormatter={(v) => `${Math.round(v)}ms`}
            width={64}
          />
          {/* Right Y1: Availability(%) */}
          <YAxis
            yAxisId="%"
            orientation="right"
            tickFormatter={(v) => `${v.toFixed(1)}%`}
            width={50}
          />
          {/* Right Y2: RPM (overlay; tool팁/범례로 구분) */}
          <YAxis
            yAxisId="rpm"
            hide
            domain={['dataMin - 100', 'dataMax + 100']}
          />
          <Tooltip
            labelFormatter={(l) => new Date(l).toLocaleString()}
            formatter={(v: number, n) =>
              n === 'p95' ? `${Math.round(v)} ms` :
              n === 'avail' ? `${v.toFixed(2)} %` :
              `${Math.round(v)} rpm`
            }
          />
          <Legend />
          <Line yAxisId="ms"    type="monotone" dataKey="p95"   name="p95 (ms)"    dot={false} strokeWidth={2} />
          <Line yAxisId="%"     type="monotone" dataKey="avail" name="Avail (%)"   dot={false} strokeDasharray="4 2" />
          <Line yAxisId="rpm"   type="monotone" dataKey="rpm"   name="RPM"         dot={false} strokeWidth={1.5} />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}
ModelSlideOver 연결 예시

tsx
복사
편집
// ModelSlideOver.tsx (live/history 탭에)
import MultiAxisStatus from '@/components/charts/MultiAxisStatus';

<MultiAxisStatus
  data={(data.recentLive ?? [])
    .slice()
    .reverse()
    .map(p => ({ ts: p.ts, p95: p.latencyP95Ms, avail: p.availability, rpm: p.rpm }))}
/>
③ Benchmark Matrix 표 컴포넌트
3-1) API 라우트 (모델×벤치마크 매트릭스)
ts
복사
편집
// /app/api/benchmarks/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/server/prisma';

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const suites = (searchParams.get('suites') || '')
    .split(',')
    .map(s => s.trim())
    .filter(Boolean);
  const norm = searchParams.get('norm') === '1';

  const scores = await prisma.benchmarkScore.findMany({
    where: suites.length ? { suite: { in: suites } } : undefined,
    include: { model: { include: { provider: true } } },
    orderBy: [{ suite: 'asc' }, { evaluatedAt: 'desc' }]
  });

  // 최신 점수만 사용 (model+suite 기준)
  const latestByKey = new Map<string, typeof scores[number]>();
  for (const s of scores) {
    const key = `${s.modelId}:${s.suite}`;
    if (!latestByKey.has(key)) latestByKey.set(key, s);
  }
  const latest = Array.from(latestByKey.values());

  // 정규화(0~100) 옵션: suite별 최소/최대 기준 간단 정규화
  if (norm) {
    const bySuite = new Map<string, typeof latest>();
    for (const r of latest) {
      const arr = bySuite.get(r.suite) || [];
      arr.push(r as any);
      bySuite.set(r.suite, arr);
    }
    for (const [suite, arr] of bySuite) {
      const vals = arr.map(a => a.scoreRaw ?? a.scoreNorm ?? 0);
      const min = Math.min(...vals);
      const max = Math.max(...vals);
      for (const a of arr) {
        const raw = a.scoreRaw ?? a.scoreNorm ?? 0;
        a.scoreNorm = max === min ? 50 : ((raw - min) / (max - min)) * 100;
      }
    }
  }

  // 응답 구조: { models: [{id,name,provider}], suites: [..], matrix: { [modelId]: { [suite]: score } } }
  const models = Array.from(new Map(latest.map(l => [l.modelId, {
    id: l.modelId, name: l.model.name, provider: l.model.provider.name
  }])).values());

  const suiteSet = Array.from(new Set(latest.map(l => l.suite)));
  const matrix: Record<string, Record<string, number>> = {};
  for (const m of models) matrix[m.id] = {};

  for (const l of latest) {
    matrix[l.modelId][l.suite] = (norm ? (l.scoreNorm ?? 0) : (l.scoreRaw ?? l.scoreNorm ?? 0));
  }

  return NextResponse.json({ models, suites: suiteSet, matrix, normalized: norm });
}
3-2) Matrix 컴포넌트 (정렬·정규화 토글·색상 스케일)
tsx
복사
편집
// /src/components/benchmark/BenchmarkMatrix.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';
import { cn } from '@/lib/utils';
import { Switch } from '@/components/ui/switch';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';

type MatrixData = {
  models: { id: string; name: string; provider: string }[];
  suites: string[];
  matrix: Record<string, Record<string, number>>;
  normalized: boolean;
};

function colorFor(value: number, normalized: boolean) {
  const v = Math.max(0, Math.min(100, normalized ? value : value)); // normalized면 0~100 가정
  const alpha = 0.12 + (v / 100) * 0.35;
  return `rgba(34,197,94,${alpha})`; // emerald-ish
}

export default function BenchmarkMatrix({ defaultSuites = [] as string[] }) {
  const [norm, setNorm] = useState(true);
  const [q, setQ] = useState('');
  const [data, setData] = useState<MatrixData | null>(null);
  const [loading, setLoading] = useState(false);

  async function load() {
    setLoading(true);
    const params = new URLSearchParams();
    if (defaultSuites.length) params.set('suites', defaultSuites.join(','));
    if (norm) params.set('norm', '1');
    const res = await fetch(`/api/benchmarks?${params.toString()}`, { cache: 'no-store' });
    const json = await res.json();
    setData(json);
    setLoading(false);
  }

  useEffect(() => { load(); /* eslint-disable-next-line */ }, [norm]);

  const filtered = useMemo(() => {
    if (!data) return data;
    const f = q.trim().toLowerCase();
    if (!f) return data;
    const models = data.models.filter(m =>
      m.name.toLowerCase().includes(f) || m.provider.toLowerCase().includes(f)
    );
    const matrix: MatrixData['matrix'] = {};
    for (const m of models) matrix[m.id] = data.matrix[m.id] || {};
    return { ...data, models, matrix };
  }, [data, q]);

  const [sortBy, setSortBy] = useState<string | null>(null);
  const sortedModels = useMemo(() => {
    if (!filtered) return [];
    const arr = filtered.models.slice();
    if (!sortBy) return arr;
    arr.sort((a, b) => {
      const av = filtered.matrix[a.id]?.[sortBy] ?? -Infinity;
      const bv = filtered.matrix[b.id]?.[sortBy] ?? -Infinity;
      return (bv - av);
    });
    return arr;
  }, [filtered, sortBy]);

  if (loading && !data) return <div className="p-4 text-slate-400">Loading…</div>;
  if (!filtered) return null;

  return (
    <div className="space-y-3">
      <div className="flex items-center gap-3">
        <Input placeholder="Search model/provider…" value={q} onChange={e => setQ(e.target.value)} className="max-w-xs" />
        <div className="flex items-center gap-2">
          <Switch checked={norm} onCheckedChange={setNorm} />
          <span className="text-sm text-slate-400">Normalize 0–100</span>
        </div>
        <div className="ml-auto flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={load}>Refresh</Button>
        </div>
      </div>

      <div className="overflow-auto rounded-xl border border-white/10">
        <table className="w-full text-sm">
          <thead className="sticky top-0 bg-slate-950/80 backdrop-blur">
            <tr>
              <th className="px-3 py-2 text-left w-[28%]">Model</th>
              {filtered.suites.map(s => (
                <th key={s} className="px-3 py-2 text-right">
                  <button
                    onClick={() => setSortBy(s)}
                    className={cn("underline-offset-4 hover:underline", sortBy === s && "text-emerald-400")}
                    title="Sort by this suite"
                  >
                    {s}
                  </button>
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {sortedModels.map(m => (
              <tr key={m.id} className="border-t border-white/5">
                <td className="px-3 py-2">
                  <div className="font-medium">{m.name}</div>
                  <div className="text-xs text-slate-400">{m.provider}</div>
                </td>
                {filtered.suites.map(s => {
                  const v = filtered.matrix[m.id]?.[s];
                  const cell = (v ?? null);
                  return (
                    <td key={s} className="px-3 py-2 text-right">
                      {cell === null ? (
                        <span className="text-slate-500">—</span>
                      ) : (
                        <span
                          className="inline-block rounded px-2 py-1"
                          style={{ background: colorFor(Number(cell), filtered.normalized) }}
                          title={String(cell)}
                        >
                          {filtered.normalized ? Math.round(Number(cell)) : Number(cell).toFixed(3)}
                        </span>
                      )}
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {sortBy && (
        <p className="text-xs text-slate-500">
          Sorted by <span className="text-slate-300">{sortBy}</span> (desc).
        </p>
      )}
    </div>
  );
}
사용 예시

tsx
복사
편집
// /app/benchmark/page.tsx
import BenchmarkMatrix from '@/components/benchmark/BenchmarkMatrix';

export default function Page() {
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-xl font-semibold">Benchmark</h1>
      <p className="text-slate-400 text-sm">
        주요 벤치마크의 최신 점수를 모델별로 비교합니다. 정규화 토글로 0–100 상대 비교가 가능합니다.
      </p>
      <BenchmarkMatrix defaultSuites={[
        'MMLU','GSM8K','HumanEval','HellaSwag','MATH','ARC-C','BBH','TruthfulQA','MT-Bench','DROP'
      ]} />
    </div>
  );
}
마무리 체크리스트
 REDIS_URL, NEXT_PUBLIC_RT_URL, RT_PORT, CORS_ORIGIN 환경변수 설정

 docker-compose up -d로 Redis·Gateway·Worker 기동(또는 로컬 프로세스)

 BenchmarkScore seed 추가(여러 suite) → /api/benchmarks 응답 확인

 ModelSlideOver에 MultiAxisStatus 연결해 실시간/최근 데이터 시각화

 Server Status 리스트는 소켓 수신값으로 주기적 갱신(이미 제공한 훅 적용)




 (A) 워커: DB 기록 + Redis Pub 통합 샘플, (B) Recharts 멀티축 + 임계(Bands) 가이드, (C) Benchmark Matrix: CSV/PNG 내보내기 순서로 드립니다. 전부 그대로 붙여 쓰면 동작하도록 의존성/경로 포함했습니다.

A) 워커: DB 기록 + Redis Publish (통합)
측정(또는 샘플 생성) → Postgres(Prisma) 에 StatusProbe 레코드 추가 → Redis Pub/Sub 으로 게이트웨이에 실시간 전파.

설치

bash
복사
편집
pnpm add ioredis
파일: /server/worker/probe-and-publish.ts

ts
복사
편집
import 'dotenv/config';
import Redis from 'ioredis';
import { PrismaClient, RegionCode } from '@prisma/client';

const prisma = new PrismaClient();
const redis  = new Redis(process.env.REDIS_URL!);

type StatusUpdate = {
  id: string;            // model id
  region: RegionCode;
  availability: number;  // 0~100
  latencyP95Ms: number;
  errorRate: number;     // 0~100
  rpm: number;
  ts: string;            // ISO
};

const CHANNEL = 'status:update:v1';

// === 1) 대상 모델/리전 조회 ===
async function getTargets() {
  const models = await prisma.model.findMany({
    select: { id: true },
    // 활성화된 모델에 대한 where 절을 추가할 수 있음
  });
  const regions: RegionCode[] = ['seoul', 'virginia', 'frankfurt'];
  return { models: models.map(m => m.id), regions };
}

// === 2) 측정(또는 샘플) 생성 ===
// 실제 환경에선 HTTP 합성 트랜잭션으로 교체
function sampleProbe() {
  const latencyP95 = 800 + Math.round(Math.random() * 400);
  const availability = 99.6 + Math.random() * 0.4;
  const errorRate = Math.random() < 0.08 ? 0.6 : 0.08;
  const rpm = 2000 + Math.round(Math.random() * 1200);
  return { latencyP95, availability, errorRate, rpm };
}

// === 3) DB 기록 + 메시지 생성 ===
async function writeAndBuildUpdates(modelIds: string[], regions: RegionCode[]): Promise<StatusUpdate[]> {
  const ts = new Date();
  const updates: StatusUpdate[] = [];
  for (const id of modelIds) {
    for (const region of regions) {
      const { latencyP95, availability, errorRate, rpm } = sampleProbe();
      // DB insert
      await prisma.statusProbe.create({
        data: {
          modelId: id,
          region,
          ts,
          latencyP50: Math.max(200, Math.round(latencyP95 * 0.6)),
          latencyP95,
          availability,
          errorRate,
          rpm
        }
      });
      // Pub payload
      updates.push({
        id,
        region,
        availability,
        latencyP95Ms: latencyP95,
        errorRate,
        rpm,
        ts: ts.toISOString()
      });
    }
  }
  return updates;
}

// === 4) Redis Publish ===
async function publish(updates: StatusUpdate[]) {
  await redis.publish(CHANNEL, JSON.stringify({ updates }));
}

// === 5) 주기 실행 루프 ===
async function tick() {
  const { models, regions } = await getTargets();
  const updates = await writeAndBuildUpdates(models, regions);
  await publish(updates);
}

async function main() {
  if (!process.env.REDIS_URL) throw new Error('REDIS_URL missing');
  console.log('✅ Worker (probe → DB → Redis) started');
  // 즉시 1회 + 15초 간격
  await tick();
  setInterval(tick, 15_000);
}

main().catch(e => {
  console.error(e);
  process.exit(1);
}).finally(async () => {
  // 프로세스 상시동작이므로 여기서는 disconnect 생략
});
게이트웨이는 기존에 드린 server/realtime/gateway.ts (Redis Subscribe → Socket.IO broadcast) 그대로 사용하세요.

B) Recharts 멀티축 + 임계(Band) 가이드
p95(ms) / Availability(%) / RPM 3개 축 + 레퍼런스 밴드로 “정상/주의/장애” 구간 시각화.

파일: /src/components/charts/MultiAxisStatusWithBands.tsx

tsx
복사
편집
'use client';

import {
  ResponsiveContainer, LineChart, Line, XAxis, YAxis, Tooltip,
  CartesianGrid, Legend, ReferenceArea, ReferenceLine
} from 'recharts';

type Point = { ts: string; p95: number; avail: number; rpm: number };

export default function MultiAxisStatusWithBands({ data }: { data: Point[] }) {
  return (
    <div className="h-80 w-full">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={data}>
          <CartesianGrid strokeOpacity={0.1} vertical={false} />
          <XAxis
            dataKey="ts"
            tickFormatter={(v) =>
              new Date(v).toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit' })
            }
            minTickGap={24}
          />

          {/* Left Y: p95 (ms) */}
          <YAxis yAxisId="ms" width={64} tickFormatter={(v) => `${Math.round(v)}ms`} />

          {/* Right Y1: Availability (%) */}
          <YAxis yAxisId="%" orientation="right" width={56} tickFormatter={(v) => `${v.toFixed(1)}%`} />

          {/* Hidden Y2 for RPM */}
          <YAxis yAxisId="rpm" hide domain={['dataMin - 100', 'dataMax + 100']} />

          <Tooltip
            labelFormatter={(l) => new Date(l).toLocaleString()}
            formatter={(v: number, n) =>
              n === 'p95' ? `${Math.round(v)} ms`
              : n === 'avail' ? `${v.toFixed(2)} %`
              : `${Math.round(v)} rpm`
            }
          />
          <Legend />

          {/* === Latency bands (ms) on Left axis === */}
          <ReferenceArea yAxisId="ms" y1={0} y2={1500} fill="rgba(16,185,129,0.08)" ifOverflow="extendDomain" />     {/* Good */}
          <ReferenceArea yAxisId="ms" y1={1500} y2={3000} fill="rgba(245,158,11,0.10)" ifOverflow="extendDomain" />  {/* Degraded */}
          <ReferenceArea yAxisId="ms" y1={3000} y2={999999} fill="rgba(244,63,94,0.10)" ifOverflow="extendDomain" /> {/* Outage */}

          {/* === Availability bands (%) on Right axis === */}
          <ReferenceArea yAxisId="%" y1={99.5} y2={101} fill="rgba(16,185,129,0.08)" ifOverflow="extendDomain" />     {/* Good */}
          <ReferenceArea yAxisId="%" y1={98.0} y2={99.5} fill="rgba(245,158,11,0.10)" ifOverflow="extendDomain" />    {/* Degraded */}
          <ReferenceArea yAxisId="%" y1={0} y2={98.0} fill="rgba(244,63,94,0.10)" ifOverflow="extendDomain" />        {/* Outage */}

          {/* 임계선(가이드) */}
          <ReferenceLine yAxisId="ms" y={1500} strokeOpacity={0.35} />
          <ReferenceLine yAxisId="ms" y={3000} strokeOpacity={0.35} />
          <ReferenceLine yAxisId="%"  y={99.5} strokeOpacity={0.35} />
          <ReferenceLine yAxisId="%"  y={98.0} strokeOpacity={0.35} />

          {/* series */}
          <Line yAxisId="ms"  type="monotone" dataKey="p95"   name="p95 (ms)"  dot={false} strokeWidth={2} />
          <Line yAxisId="%"   type="monotone" dataKey="avail" name="Avail (%)" dot={false} strokeDasharray="4 2" />
          <Line yAxisId="rpm" type="monotone" dataKey="rpm"   name="RPM"       dot={false} strokeWidth={1.5} />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}
ModelSlideOver의 live/history 섹션에서 기존 멀티축 차트를 이 컴포넌트로 교체하면 됩니다.

C) Benchmark Matrix: CSV/PNG 내보내기
CSV: 현재 테이블 데이터를 문자열로 만들고 Blob 다운로드

PNG: 클라이언트에서 DOM 캡쳐 → PNG. html-to-image 사용

설치

bash
복사
편집
pnpm add html-to-image
업데이트: /src/components/benchmark/BenchmarkMatrix.tsx (핵심 부분만 추가/수정)

tsx
복사
편집
'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { cn } from '@/lib/utils';
import { Switch } from '@/components/ui/switch';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import * as htmlToImage from 'html-to-image';

type MatrixData = {
  models: { id: string; name: string; provider: string }[];
  suites: string[];
  matrix: Record<string, Record<string, number>>;
  normalized: boolean;
};

function colorFor(value: number, normalized: boolean) {
  const v = Math.max(0, Math.min(100, normalized ? value : value));
  const alpha = 0.12 + (v / 100) * 0.35;
  return `rgba(34,197,94,${alpha})`;
}

export default function BenchmarkMatrix({ defaultSuites = [] as string[] }) {
  const [norm, setNorm] = useState(true);
  const [q, setQ] = useState('');
  const [data, setData] = useState<MatrixData | null>(null);
  const [loading, setLoading] = useState(false);
  const [sortBy, setSortBy] = useState<string | null>(null);

  const tableRef = useRef<HTMLDivElement>(null); // PNG 캡쳐용

  async function load() {
    setLoading(true);
    const params = new URLSearchParams();
    if (defaultSuites.length) params.set('suites', defaultSuites.join(','));
    if (norm) params.set('norm', '1');
    const res = await fetch(`/api/benchmarks?${params.toString()}`, { cache: 'no-store' });
    const json = await res.json();
    setData(json);
    setLoading(false);
  }

  useEffect(() => { load(); /* eslint-disable-next-line */ }, [norm]);

  const filtered = useMemo(() => {
    if (!data) return data;
    const f = q.trim().toLowerCase();
    if (!f) return data;
    const models = data.models.filter(m =>
      m.name.toLowerCase().includes(f) || m.provider.toLowerCase().includes(f)
    );
    const matrix: MatrixData['matrix'] = {};
    for (const m of models) matrix[m.id] = data.matrix[m.id] || {};
    return { ...data, models, matrix };
  }, [data, q]);

  const sortedModels = useMemo(() => {
    if (!filtered) return [];
    const arr = filtered.models.slice();
    if (!sortBy) return arr;
    arr.sort((a, b) => {
      const av = filtered.matrix[a.id]?.[sortBy] ?? -Infinity;
      const bv = filtered.matrix[b.id]?.[sortBy] ?? -Infinity;
      return (bv - av);
    });
    return arr;
  }, [filtered, sortBy]);

  // === CSV Export ===
  function exportCSV() {
    if (!filtered) return;
    const rows: string[][] = [];
    // header
    rows.push(['Model', 'Provider', ...filtered.suites]);
    // body
    for (const m of sortedModels) {
      const cells = filtered.suites.map(s => {
        const v = filtered.matrix[m.id]?.[s];
        if (v == null) return '';
        return filtered.normalized ? String(Math.round(Number(v))) : String(Number(v));
      });
      rows.push([m.name, m.provider, ...cells]);
    }
    const csv = rows.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `benchmark-matrix${filtered.normalized ? '-norm' : ''}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // === PNG Export ===
  async function exportPNG() {
    if (!tableRef.current) return;
    const dataUrl = await htmlToImage.toPng(tableRef.current, {
      backgroundColor: '#0B1220', // 다크배경 근사
      pixelRatio: 2,
      cacheBust: true,
      style: { padding: '8px' },
    });
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = 'benchmark-matrix.png';
    a.click();
  }

  if (loading && !data) return <div className="p-4 text-slate-400">Loading…</div>;
  if (!filtered) return null;

  return (
    <div className="space-y-3">
      <div className="flex items-center gap-3">
        <Input placeholder="Search model/provider…" value={q} onChange={e => setQ(e.target.value)} className="max-w-xs" />
        <div className="flex items-center gap-2">
          <Switch checked={norm} onCheckedChange={setNorm} />
          <span className="text-sm text-slate-400">Normalize 0–100</span>
        </div>
        <div className="ml-auto flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={load}>Refresh</Button>
          <Button variant="outline" size="sm" onClick={exportCSV}>Export CSV</Button>
          <Button variant="outline" size="sm" onClick={exportPNG}>Export PNG</Button>
        </div>
      </div>

      <div ref={tableRef} className="overflow-auto rounded-xl border border-white/10">
        <table className="w-full text-sm">
          <thead className="sticky top-0 bg-slate-950/80 backdrop-blur">
            <tr>
              <th className="px-3 py-2 text-left w-[28%]">Model</th>
              {filtered.suites.map(s => (
                <th key={s} className="px-3 py-2 text-right">
                  <button
                    onClick={() => setSortBy(s)}
                    className={cn("underline-offset-4 hover:underline", sortBy === s && "text-emerald-400")}
                    title="Sort by this suite"
                  >
                    {s}
                  </button>
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {sortedModels.map(m => (
              <tr key={m.id} className="border-t border-white/5">
                <td className="px-3 py-2">
                  <div className="font-medium">{m.name}</div>
                  <div className="text-xs text-slate-400">{m.provider}</div>
                </td>
                {filtered.suites.map(s => {
                  const v = filtered.matrix[m.id]?.[s];
                  const cell = (v ?? null);
                  return (
                    <td key={s} className="px-3 py-2 text-right">
                      {cell === null ? (
                        <span className="text-slate-500">—</span>
                      ) : (
                        <span
                          className="inline-block rounded px-2 py-1"
                          style={{ background: colorFor(Number(cell), filtered.normalized) }}
                          title={String(cell)}
                        >
                          {filtered.normalized ? Math.round(Number(cell)) : Number(cell).toFixed(3)}
                        </span>
                      )}
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {sortBy && (
        <p className="text-xs text-slate-500">
          Sorted by <span className="text-slate-300">{sortBy}</span> (desc).
        </p>
      )}
    </div>
  );
}
적용 체크리스트
[.env] REDIS_URL, NEXT_PUBLIC_RT_URL 설정

게이트웨이 구동: tsx server/realtime/gateway.ts

워커 구동: tsx server/worker/probe-and-publish.ts

ModelSlideOver → MultiAxisStatusWithBands 연결

Benchmark 페이지에서 내보내기 버튼 동작 확인(CSV/PNG)




 ① 워커 합성 트랜잭션(모델 API 핑) 템플릿, ② 게이트웨이: Redis Stream/Cluster 구성, ③ Benchmark Matrix PDF 출력(puppeteer 서버 렌더) 를 바로 붙여쓸 수 있는 형태로 드립니다. (Node/TS + Next.js App Router + Prisma + ioredis + puppeteer 가정)

① 워커: 합성 트랜잭션(각 모델 API 핑) 템플릿
목표: 최소 토큰/짧은 프롬프트로 200 OK + 응답을 확인하고, 지연(p50/p95), 가용성, 오류율, RPM을 산출 → DB 기록 + Redis Pub.

A-1) 공통 유틸
/server/worker/lib/http.ts

ts
복사
편집
import fetch, { RequestInit } from 'node-fetch';

export type ProbeResult = {
  ok: boolean;
  latencyMs: number;
  status: number;
  bytes?: number;
  error?: string;
};

export async function timedFetch(url: string, init: RequestInit, timeoutMs = 7000): Promise<ProbeResult> {
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  const started = performance.now();
  try {
    const res = await fetch(url, { ...init, signal: ctrl.signal });
    const buf = await res.arrayBuffer(); // 응답 크기 측정
    const latencyMs = performance.now() - started;
    return { ok: res.ok, latencyMs, status: res.status, bytes: buf.byteLength };
  } catch (e: any) {
    return { ok: false, latencyMs: performance.now() - started, status: 0, error: e?.message || String(e) };
  } finally {
    clearTimeout(t);
  }
}

export async function withRetry<T>(fn: () => Promise<T>, attempts = 2, backoffMs = 400): Promise<T> {
  let lastErr: any;
  for (let i = 0; i < attempts; i++) {
    try { return await fn(); } catch (e) { lastErr = e; }
    await new Promise(r => setTimeout(r, backoffMs * (i + 1)));
  }
  throw lastErr;
}
A-2) 프로바이더별 핑(예시: OpenAI / Anthropic / Google / Mistral)
주의: 실제 계정 키는 서버 환경변수에 저장, 짧은 입력·출력 제한을 강제하여 비용 최소화.

/server/worker/lib/pings.ts

ts
복사
편집
import { timedFetch, withRetry, ProbeResult } from './http';

type PingOpts = { prompt?: string; timeoutMs?: number };

const JSON_HEADERS = { 'Content-Type': 'application/json' };

// OpenAI: responses API (chat)
// https://api.openai.com/v1/responses
export async function pingOpenAI(model: string, { prompt = 'ping', timeoutMs = 7000 }: PingOpts): Promise<ProbeResult> {
  const url = 'https://api.openai.com/v1/responses';
  return withRetry(() => timedFetch(url, {
    method: 'POST',
    headers: {
      ...JSON_HEADERS,
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`
    },
    body: JSON.stringify({
      model, input: prompt,
      max_output_tokens: 5, temperature: 0,
      metadata: { probe: true }
    })
  }, timeoutMs));
}

// Anthropic: Messages API
export async function pingAnthropic(model: string, { prompt = 'ping', timeoutMs = 7000 }: PingOpts): Promise<ProbeResult> {
  const url = 'https://api.anthropic.com/v1/messages';
  return withRetry(() => timedFetch(url, {
    method: 'POST',
    headers: {
      ...JSON_HEADERS,
      'x-api-key': process.env.ANTHROPIC_API_KEY!,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model, max_tokens: 8, temperature: 0,
      messages: [{ role: 'user', content: prompt }]
    })
  }, timeoutMs));
}

// Google: Gemini API (text)
export async function pingGoogle(model: string, { prompt = 'ping', timeoutMs = 7000 }: PingOpts): Promise<ProbeResult> {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${process.env.GOOGLE_API_KEY!}`;
  return withRetry(() => timedFetch(url, {
    method: 'POST',
    headers: JSON_HEADERS,
    body: JSON.stringify({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      generationConfig: { maxOutputTokens: 8, temperature: 0 }
    })
  }, timeoutMs));
}

// Mistral: v1/chat/completions
export async function pingMistral(model: string, { prompt = 'ping', timeoutMs = 7000 }: PingOpts): Promise<ProbeResult> {
  const url = 'https://api.mistral.ai/v1/chat/completions';
  return withRetry(() => timedFetch(url, {
    method: 'POST',
    headers: {
      ...JSON_HEADERS,
      'Authorization': `Bearer ${process.env.MISTRAL_API_KEY!}`
    },
    body: JSON.stringify({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 8, temperature: 0
    })
  }, timeoutMs));
}
A-3) 합성 트랜잭션 실행 → DB 기록 + Redis Pub
/server/worker/synthetic.ts

ts
복사
편집
import 'dotenv/config';
import Redis from 'ioredis';
import { PrismaClient, RegionCode } from '@prisma/client';
import { pingOpenAI, pingAnthropic, pingGoogle, pingMistral } from './lib/pings';

const prisma = new PrismaClient();
const redis  = new Redis(process.env.REDIS_URL!);
const CHANNEL = 'status:update:v1';

type ProviderPing = (model: string, opts?: any) => Promise<{ ok: boolean; latencyMs: number; status: number; error?: string }>;

type Target = {
  modelId: string;
  provider: 'openai'|'anthropic'|'google'|'mistral';
  apiModel: string; // 실제 API 모델명
};

async function getTargets(): Promise<Target[]> {
  // Prisma에서 대상 모델/프로바이더를 가져오거나, 구성 테이블/ENV에서 로드
  const rows = await prisma.model.findMany({
    include: { provider: true }
  });
  // 매핑 규칙 (예시)
  return rows.map(r => {
    const name = r.provider.name.toLowerCase();
    const provider = name.includes('openai') ? 'openai'
      : name.includes('anthropic') ? 'anthropic'
      : name.includes('google') ? 'google'
      : name.includes('mistral') ? 'mistral' : 'openai';
    // apiModel은 r.apiVersion/foundationModel로 매핑하거나 별도 필드 사용
    return { modelId: r.id, provider, apiModel: r.name };
  });
}

function getPinger(p: Target['provider']): ProviderPing {
  switch (p) {
    case 'openai': return pingOpenAI as any;
    case 'anthropic': return pingAnthropic as any;
    case 'google': return pingGoogle as any;
    case 'mistral': return pingMistral as any;
  }
}

const REGIONS: RegionCode[] = ['seoul','virginia']; // POP

async function runOnce() {
  const ts = new Date();
  const targets = await getTargets();

  const updates: any[] = [];

  for (const region of REGIONS) {
    // 지역 POP에서 실행되는 것을 가정(여기선 단일 워커이므로 region 필드만 세팅)
    for (const t of targets) {
      const pinger = getPinger(t.provider);
      const res = await pinger(t.apiModel, { prompt: 'ping', timeoutMs: 7000 });

      // 단일 측정 → 간단 산출 (실운영은 가중/윈도우 집계가 좋음)
      const latencyP95 = Math.round(res.latencyMs);
      const availability = res.ok ? 100 : 0; // 최소 구현(실제는 윈도우 집계 %)
      const errorRate = res.ok ? 0 : 100;
      const rpm = 1; // 합성 트랜잭션 수(초간단)

      await prisma.statusProbe.create({
        data: {
          modelId: t.modelId,
          region,
          ts,
          latencyP50: Math.round(latencyP95 * 0.6),
          latencyP95,
          availability,
          errorRate,
          rpm
        }
      });

      updates.push({
        id: t.modelId,
        region,
        availability,
        latencyP95Ms: latencyP95,
        errorRate,
        rpm,
        ts: ts.toISOString()
      });
    }
  }

  await redis.publish(CHANNEL, JSON.stringify({ updates }));
}

(async function main() {
  if (!process.env.REDIS_URL) throw new Error('REDIS_URL missing');
  console.log('✅ Synthetic worker started');
  await runOnce();
  setInterval(runOnce, 60_000); // 1분 간격
})();
POP 분산을 원하면 지역별 컨테이너/잡을 배치하고 REGION=seoul 식으로 단일 리전에만 기록하도록 분리하세요.

② 게이트웨이: Redis Stream + Cluster 구성
의도: Pub/Sub 대신 Redis Streams로 내구성/재처리 확보. 다수 게이트웨이가 Consumer Group으로 구독. Cluster 환경도 지원.

B-1) Cluster 클라이언트 & XREADGROUP
/server/realtime/gateway-stream.ts

ts
복사
편집
import http from 'http';
import { Server } from 'socket.io';
import Redis, { Cluster } from 'ioredis';

const PORT = Number(process.env.RT_PORT || 4001);
const CORS = process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'];

// --- Redis (Cluster or single) ---
function createRedisReader() {
  if (process.env.REDIS_CLUSTER_NODES) {
    const nodes = process.env.REDIS_CLUSTER_NODES.split(',').map(n => {
      const [host, port] = n.split(':');
      return { host, port: Number(port) };
    });
    return new Cluster(nodes);
  }
  return new Redis(process.env.REDIS_URL!);
}

const STREAM_KEY = process.env.RT_STREAM_KEY || 'status:updates:x';
const GROUP = process.env.RT_CONSUMER_GROUP || 'gw';
const CONSUMER = `gw-${Math.random().toString(36).slice(2, 8)}`;

async function ensureGroup(r: Redis | Cluster) {
  try {
    // MKSTREAM: 스트림이 없으면 생성
    await (r as any).xgroup('CREATE', STREAM_KEY, GROUP, '$', 'MKSTREAM');
  } catch (e: any) {
    if (!String(e?.message).includes('BUSYGROUP')) throw e;
  }
}

async function readLoop(r: Redis | Cluster, onBatch: (items: any[]) => Promise<void>) {
  await ensureGroup(r);
  while (true) {
    // block 5s, read 100
    const resp = await (r as any).xreadgroup('GROUP', GROUP, CONSUMER, 'BLOCK', 5000, 'COUNT', 100, 'STREAMS', STREAM_KEY, '>');
    if (!resp) continue;
    // resp: [[STREAM_KEY, [[id, [field, value, field, value ...]], ...]]]
    const [, entries] = resp[0];
    const items = entries.map(([id, kv]: [string, string[]]) => {
      const obj: Record<string, string> = {};
      for (let i = 0; i < kv.length; i += 2) obj[kv[i]] = kv[i + 1];
      return { id, obj };
    });

    // payload parsing
    const updates: any[] = [];
    for (const it of items) {
      try {
        const u = JSON.parse(it.obj.payload); // {updates: [...]}
        updates.push(...(u.updates || []));
      } catch {}
    }
    if (updates.length) await onBatch(updates);

    // ack
    for (const it of items) await (r as any).xack(STREAM_KEY, GROUP, it.id);
  }
}

// --- WS Gateway ---
const server = http.createServer();
const io = new Server(server, { cors: { origin: CORS } });

const reader = createRedisReader();

readLoop(reader, async (updates) => {
  io.emit('status:update', updates);
});

server.listen(PORT, () => console.log(`✅ Realtime gateway(stream) :${PORT}`));
B-2) 워커가 Streams로 push
/server/worker/stream-writer.ts

ts
복사
편집
import 'dotenv/config';
import Redis, { Cluster } from 'ioredis';

const STREAM_KEY = process.env.RT_STREAM_KEY || 'status:updates:x';

function createWriter() {
  if (process.env.REDIS_CLUSTER_NODES) {
    const nodes = process.env.REDIS_CLUSTER_NODES.split(',').map(n => {
      const [host, port] = n.split(':');
      return { host, port: Number(port) };
    });
    return new Cluster(nodes);
  }
  return new Redis(process.env.REDIS_URL!);
}

const redis = createWriter();

export async function streamPublish(updates: any[]) {
  // field-value pairs
  const fields = ['payload', JSON.stringify({ updates })];
  await (redis as any).xadd(STREAM_KEY, '*', ...fields);
}

// 데모
if (require.main === module) {
  (async () => {
    await streamPublish([{ id: 'demo', region: 'seoul', availability: 100, latencyP95Ms: 900, errorRate: 0, rpm: 10, ts: new Date().toISOString() }]);
    process.exit(0);
  })();
}
운영에서는 기존 Pub 대신 streamPublish(updates)로 교체하세요.
장점: 게이트웨이 다운타임에도 메시지 유실 없음, 다수 게이트웨이가 Consumer Group으로 수평 확장 가능.

③ Matrix PDF 출력 (puppeteer 서버 렌더)
전략: Next.js API 라우트에서 /benchmark/print?params... 페이지를 headless Chromium으로 열어 PDF로 저장 → 바이트 스트림 응답.

C-1) 인쇄용 페이지(간단 스타일)
/app/benchmark/print/page.tsx

tsx
복사
편집
// 인쇄전용(여백/배경 통합) - 서버 렌더 관점에서 간결
import BenchmarkMatrix from '@/components/benchmark/BenchmarkMatrix';

export const dynamic = 'force-dynamic';

export default function PrintPage() {
  return (
    <div style={{ padding: 16, background: '#0B1220', color: 'white' }}>
      <h1 style={{ fontSize: 20, marginBottom: 8 }}>Benchmark Matrix</h1>
      <p style={{ opacity: .7, marginBottom: 12 }}>Generated at {new Date().toLocaleString()}</p>
      <BenchmarkMatrix defaultSuites={[
        'MMLU','GSM8K','HumanEval','HellaSwag','MATH','ARC-C','BBH','TruthfulQA','MT-Bench','DROP'
      ]}/>
    </div>
  );
}
C-2) puppeteer 라우트
설치

bash
복사
편집
pnpm add puppeteer
/app/api/benchmark/pdf/route.ts

ts
복사
편집
import { NextResponse } from 'next/server';
import puppeteer from 'puppeteer';

export const maxDuration = 60; // Vercel 등 무중단 환경 고려 시 조정

export async function GET(req: Request) {
  const base = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
  const url = `${base}/benchmark/print`;
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox','--disable-setuid-sandbox','--font-render-hinting=none']
  });

  try {
    const page = await browser.newPage();
    await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });

    // 다크배경 포함하여 PDF 렌더
    const pdf = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: { top: '10mm', bottom: '12mm', left: '8mm', right: '8mm' },
      preferCSSPageSize: false
    });

    return new NextResponse(pdf, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `inline; filename="benchmark-matrix.pdf"`
      }
    });
  } finally {
    await browser.close();
  }
}
환경 변수

ini
복사
편집
NEXT_PUBLIC_BASE_URL=http://localhost:3000   # 프로덕션 도메인으로 설정
C-3) UI에서 PDF 버튼
/app/benchmark/page.tsx (추가 버튼)

tsx
복사
편집
import BenchmarkMatrix from '@/components/benchmark/BenchmarkMatrix';

export default function Page() {
  const pdf = async () => {
    window.open('/api/benchmark/pdf', '_blank');
  };
  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-xl font-semibold">Benchmark</h1>
        <button onClick={pdf} className="rounded border border-white/20 px-3 py-1 text-sm">Export PDF</button>
      </div>
      <p className="text-slate-400 text-sm">
        주요 벤치마크의 최신 점수를 모델별로 비교합니다. 정규화 토글로 0–100 상대 비교가 가능합니다.
      </p>
      <BenchmarkMatrix defaultSuites={[
        'MMLU','GSM8K','HumanEval','HellaSwag','MATH','ARC-C','BBH','TruthfulQA','MT-Bench','DROP'
      ]} />
    </div>
  );
}
운영 팁 / 체크리스트
합성 트랜잭션 비용/한도

각 프로바이더 키는 POP/환경별로 분리 (한도 충돌 방지)

max_output_tokens를 5~8로 제한, 프롬프트는 단문(“ping”)

시간창(슬라이딩 윈도우)으로 가용성% 계산(예: 5분·15분)

Streams vs Pub/Sub

잦은 단기 업데이트에 Pub/Sub가 가볍지만, 유실 방지/다중 게이트웨이는 Streams+Group 권장

게이트웨이 재시작 시 펜딩 처리(XAUTOCLAIM) 로 누락 복구 고려

puppeteer 런타임

Linux 컨테이너: --no-sandbox 필요, 기본 폰트 패키지 설치(한글 필요 시 fonts-noto-cjk)

무거운 페이지는 waitUntil: 'networkidle2' + 추가 await page.waitForSelector(...) 사용



 (A) 가용성% 계산기 — 순수 SQL & TimescaleDB 연속 집계(continuous aggregate), (B) 게이트웨이 XAUTOCLAIM 기반 펜딩 복구 루틴(Streams 소비자 그룹 안정화), (C) 인쇄용 Matrix 라이트 테마 PDF(전용 라이트 페이지 + API) 를 바로 붙여 쓸 수 있게 정리했습니다.

A) 가용성% 계산기
A-1) 순수 Postgres(윈도우 집계 SQL)
StatusProbe를 1분 주기로 적재한다고 가정(당신 seed 기준). 최근 5분 가용성%를 모델×리전 단위로 계산:

sql
복사
편집
-- 가용성 산식(권장):
-- success = (error_rate < 50%) AND (latency_p95_ms < 3000ms)
-- availability_% = 100 * successes / total
WITH recent AS (
  SELECT
    model_id,
    region,
    ts,
    (CASE
       WHEN coalesce(error_rate,0) < 50 AND coalesce(latency_p95, 999999) < 3000
         THEN 1 ELSE 0
     END) AS success
  FROM "StatusProbe"
  WHERE ts >= now() - interval '5 minutes'
),
agg AS (
  SELECT
    model_id,
    region,
    COUNT(*) AS total,
    SUM(success) AS succ
  FROM recent
  GROUP BY model_id, region
)
SELECT
  model_id,
  region,
  CASE WHEN total = 0 THEN 0
       ELSE ROUND(100.0 * succ::numeric / total, 2)
  END AS availability_5m
FROM agg
ORDER BY availability_5m DESC;
비고

기존 스키마에 availability(0~100)가 있으므로, 단순 평균으로도 계산 가능:

sql
복사
편집
SELECT model_id, region, ROUND(AVG(availability),2) AS availability_5m
FROM "StatusProbe"
WHERE ts >= now() - interval '5 minutes'
GROUP BY model_id, region;
첫 번째 방식은 오류율·지연 임계치 기반이라 SLO 집계에 적합합니다.

A-2) TimescaleDB 연속 집계(continuous aggregate)
하이퍼테이블 변환(+ 인덱스)

sql
복사
편집
SELECT create_hypertable('"StatusProbe"', 'ts', if_not_exists => TRUE);
CREATE INDEX IF NOT EXISTS statusprobe_model_region_ts_idx
  ON "StatusProbe"(model_id, region, ts DESC);
5분 버킷 기준 연속 집계 뷰(임계식 사용)

sql
복사
편집
CREATE MATERIALIZED VIEW cagg_availability_5m
WITH (timescaledb.continuous) AS
SELECT
  time_bucket('5 minutes', ts) AS bucket,
  model_id,
  region,
  COUNT(*)                       AS total,
  SUM(
    CASE WHEN coalesce(error_rate,0) < 50
           AND coalesce(latency_p95, 999999) < 3000
         THEN 1 ELSE 0 END
  )                              AS succ,
  100.0 * SUM(
    CASE WHEN coalesce(error_rate,0) < 50
           AND coalesce(latency_p95, 999999) < 3000
         THEN 1 ELSE 0 END
  ) / GREATEST(COUNT(*),1)       AS availability_pct
FROM "StatusProbe"
GROUP BY bucket, model_id, region;
새 데이터 반영 정책(지연 허용창 + 리프레시)

sql
복사
편집
-- 최근 1일 범위에 대해 2분마다 리프레시
SELECT add_continuous_aggregate_policy('cagg_availability_5m',
  start_offset => INTERVAL '1 day',
  end_offset   => INTERVAL '1 minute',
  schedule_interval => INTERVAL '2 minutes');
조회(최근 버킷 or 범위)

sql
복사
편집
-- 최신 버킷의 모델×리전 가용성
SELECT *
FROM cagg_availability_5m
WHERE bucket = time_bucket('5 minutes', now());

-- 최근 24h 트렌드
SELECT *
FROM cagg_availability_5m
WHERE bucket >= now() - interval '24 hours'
  AND model_id = $1 AND region = $2
ORDER BY bucket;
B) 게이트웨이 XAUTOCLAIM 기반 펜딩 복구(Streams Consumer Group)
다중 게이트웨이/예상 크래시 상황에서 펜딩 항목을 고아 상태로 두지 않도록, 일정 시간(예: 60초) 이상 처리되지 않은 메시지를 스스로 클레임하여 브로드캐스트합니다.

ts
복사
편집
// /server/realtime/pending-recover.ts
import Redis, { Cluster } from 'ioredis';

type R = Redis | Cluster;
const STREAM = process.env.RT_STREAM_KEY || 'status:updates:x';
const GROUP  = process.env.RT_CONSUMER_GROUP || 'gw';
const CONSUMER = process.env.RT_CONSUMER_NAME || `gw-${Math.random().toString(36).slice(2,8)}`;

export async function pendingRecoverLoop(r: R, onBatch: (payloads: any[]) => Promise<void>) {
  // min-idle-time: 60s (그보다 오래 펜딩된 항목 클레임)
  const MIN_IDLE_MS = 60_000;

  // 5초마다 펜딩 회수 시도
  setInterval(async () => {
    try {
      // XAUTOCLAIM key group consumer min-idle start [COUNT count] [JUSTID]
      const res: any = await (r as any).xautoclaim(STREAM, GROUP, CONSUMER, MIN_IDLE_MS, '0-0', 'COUNT', 100);
      // res = [next_start, [[id, [field, value,...]], ...]]
      const entries = res?.[1] ?? [];
      if (!entries.length) return;

      const payloads: any[] = [];
      for (const [id, kv] of entries) {
        const obj: Record<string, string> = {};
        for (let i = 0; i < kv.length; i += 2) obj[kv[i]] = kv[i + 1];
        try {
          const parsed = JSON.parse(obj.payload);
          payloads.push(...(parsed.updates || []));
        } catch {}
        // 즉시 ACK하여 재중복 최소화(브로드캐스트 후 ACK하려면 위치 변경)
        await (r as any).xack(STREAM, GROUP, id);
      }
      if (payloads.length) await onBatch(payloads);
    } catch (e) {
      console.error('pendingRecoverLoop error', e);
    }
  }, 5000);
}
게이트웨이(Streams 버전)와 결합:

ts
복사
편집
// /server/realtime/gateway-stream.ts (발췌)
import http from 'http';
import { Server } from 'socket.io';
import Redis, { Cluster } from 'ioredis';
import { pendingRecoverLoop } from './pending-recover';

const io = new Server(http.createServer(), { /* ... */ });
const reader: Redis | Cluster = /* cluster or single */;

// 기존 readLoop(reader, onBatch)와 함께 병행 실행
pendingRecoverLoop(reader, async (updates) => {
  io.emit('status:update', updates);
});
팁

XINFO CONSUMERS stream group로 죽은 컨슈머를 탐지해 자동 클린업 루틴을 추가하면 더 안정적입니다.

재시도 다중 브로드캐스트 방지:

ACK 타이밍을 “브로드캐스트 후 ACK”로 바꾸는 대신, 메시지 ID 기반 중복 방지 캐시(TTL 수 초)를 두어도 좋습니다(예: Redis SETEX).

C) 인쇄용 Matrix 라이트 테마 PDF
C-1) 라이트 전용 인쇄 페이지
다크 스타일과 별도로 밝은 배경 + 테이블 라이트 톤.

tsx
복사
편집
// /app/benchmark/print-light/page.tsx
import BenchmarkMatrix from '@/components/benchmark/BenchmarkMatrix';

export const dynamic = 'force-dynamic';

export default function PrintLightPage() {
  return (
    <div style={{
      padding: 16,
      background: '#ffffff',
      color: '#0b1220',
      fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial'
    }}>
      <h1 style={{ fontSize: 20, marginBottom: 8 }}>Benchmark Matrix (Light)</h1>
      <p style={{ opacity: .7, marginBottom: 12 }}>
        Generated at {new Date().toLocaleString()}
      </p>

      {/* 라이트 배경에 어울리게 테이블 컨테이너만 옅은 테두리 */}
      <div style={{ border: '1px solid rgba(0,0,0,0.08)', borderRadius: 12, overflow: 'hidden' }}>
        <BenchmarkMatrix
          defaultSuites={[
            'MMLU','GSM8K','HumanEval','HellaSwag','MATH','ARC-C','BBH','TruthfulQA','MT-Bench','DROP'
          ]}
        />
      </div>
    </div>
  );
}
참고: BenchmarkMatrix 내부 배경/테두리가 다크 기준이라면, className/스타일 props를 추가해 라이트 모드용 색을 오버라이드해도 됩니다. (또는 BenchmarkMatrixLight.tsx로 경량 복제)

C-2) Puppeteer 라우트(라이트)
ts
복사
편집
// /app/api/benchmark/pdf-light/route.ts
import { NextResponse } from 'next/server';
import puppeteer from 'puppeteer';

export const maxDuration = 60;

export async function GET() {
  const base = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
  const url  = `${base}/benchmark/print-light`;

  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox','--disable-setuid-sandbox']
  });

  try {
    const page = await browser.newPage();
    // 라이트 PDF는 흰 배경이 기본
    await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
    const pdf = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: { top: '10mm', bottom: '12mm', left: '8mm', right: '8mm' }
    });

    return new NextResponse(pdf, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': 'inline; filename="benchmark-matrix-light.pdf"'
      }
    });
  } finally {
    await browser.close();
  }
}
C-3) UI 버튼(라이트 PDF)
tsx
복사
편집
// /app/benchmark/page.tsx (추가)
<button
  onClick={() => window.open('/api/benchmark/pdf-light', '_blank')}
  className="rounded border border-white/20 px-3 py-1 text-sm"
>
  Export PDF (Light)
</button>
마무리 체크리스트
가용성 집계

SLO 임계(지연/오류율) 확정 → SQL/Continuous Aggregate 적용

알림은 cagg 기반으로 Good/Degraded/Outage 상태 전이 시 트리거

Streams 운영

게이트웨이 다중화 시 Consumer Group & XAUTOCLAIM 루프 활성화

XINFO GROUPS/CONSUMERS로 헬스 체크 대시보드 구성

필요 시 중복방지 캐시(최근 메시지ID SET, TTL 10s)

PDF 렌더

서버 환경에 폰트 설치(한글 필요 시: Noto Sans CJK)

대용량 테이블은 페이지 분할 CSS 고려(page-break-inside: avoid)

프로덕션 도메인 NEXT_PUBLIC_BASE_URL 세팅



1) Timescale Continuous Aggregates 자동 Vacuum/Retention 정책
1-1) 기본 권장(압축+재정렬+보존)
sql
복사
편집
-- 1) 하이퍼테이블 등록(이미 되어있다면 생략)
SELECT create_hypertable('"StatusProbe"', 'ts', if_not_exists => TRUE);

-- 2) 압축 사용
ALTER TABLE "StatusProbe"
  SET (timescaledb.compress,
       timescaledb.compress_segmentby = 'model_id,region');

-- 3) 오래된 청크는 자동 압축 (버킷/보존 주기에 맞춰 조정)
SELECT add_compression_policy('StatusProbe',
  compress_after => INTERVAL '2 days');

-- 4) 청크 내부 시간순 정렬(압축 전 재정렬)
SELECT add_reorder_policy('StatusProbe',
  index_name => 'statusprobe_model_region_ts_idx');

-- 5) 보존(원본 프로브 데이터: 30일만 유지)
SELECT add_retention_policy('StatusProbe',
  INTERVAL '30 days');
1-2) CAGG(연속 집계) 정책
sql
복사
편집
-- 연속 집계 뷰 (예: 5분 가용성)
CREATE MATERIALIZED VIEW IF NOT EXISTS cagg_availability_5m
WITH (timescaledb.continuous) AS
SELECT time_bucket('5 minutes', ts) AS bucket,
       model_id, region,
       COUNT(*) AS total,
       SUM(CASE WHEN COALESCE(error_rate,0) < 50
                  AND COALESCE(latency_p95, 999999) < 3000
                THEN 1 ELSE 0 END) AS succ,
       100.0 * SUM(CASE WHEN COALESCE(error_rate,0) < 50
                          AND COALESCE(latency_p95, 999999) < 3000
                        THEN 1 ELSE 0 END) / GREATEST(COUNT(*),1)
         AS availability_pct
FROM "StatusProbe"
GROUP BY bucket, model_id, region;

-- 새 데이터 갱신(최근 1일 범위 리프레시)
SELECT add_continuous_aggregate_policy('cagg_availability_5m',
  start_offset => INTERVAL '1 day',
  end_offset   => INTERVAL '1 minute',
  schedule_interval => INTERVAL '2 minutes');

-- CAGG 결과의 보존(예: 180일)
SELECT add_retention_policy('cagg_availability_5m',
  INTERVAL '180 days');

-- CAGG 청크도 압축(선택)
ALTER MATERIALIZED VIEW cagg_availability_5m
  SET (timescaledb.compress,
       timescaledb.compress_segmentby = 'model_id,region');
SELECT add_compression_policy('cagg_availability_5m',
  compress_after => INTERVAL '3 days');
1-3) Autovacuum 튜닝(선택)
Autovacuum은 보통 기본값으로 충분합니다. 고트래픽이면 테이블별로 조금 공격적으로:

sql
복사
편집
ALTER TABLE "StatusProbe"
  SET (autovacuum_vacuum_scale_factor = 0.05,  -- 5% 변경 시 VACUUM
       autovacuum_analyze_scale_factor = 0.02, -- 2% 변경 시 ANALYZE
       autovacuum_vacuum_cost_limit = 400);
운영 팁

순서: write → reorder → compress → retention(older drop).

쿼리 경로 분리: 실시간 화면은 원본/최근 청크, 히스토리는 CAGG 조회.

모니터링: timescaledb_information.jobs, chunk_stats 확인.

2) Redis Streams Dead-Letter Queue(DLQ) 설계 (XADD DLQ)
2-1) 설계 원칙
필수 필드: payload(원본), err, retries, first_seen_ts, last_error_ts, consumer.

재시도 한도 초과/포맷 오류/비복구성 에러 → DLQ로 이동(XADD dlq:status).

관찰: XPENDING/XINFO GROUPS로 backlog 감시, DLQ는 별도 소비자(알람/대시보드).

2-2) 게이트웨이 소비 루프(요지)
ts
복사
편집
// gateway-stream.ts (핵심 부분만)
import Redis from 'ioredis';
const r = new Redis(process.env.REDIS_URL!);
const STREAM = process.env.RT_STREAM_KEY || 'status:updates:x';
const GROUP  = process.env.RT_CONSUMER_GROUP || 'gw';
const CONSUMER = process.env.RT_CONSUMER_NAME || `gw-${Date.now()}`;

async function xaddDLQ(reason: string, entry: { id: string; fields: string[] }, retries = 0) {
  const obj: any = {};
  for (let i=0;i<entry.fields.length;i+=2) obj[entry.fields[i]] = entry.fields[i+1];
  await r.xadd('dlq:status', '*',
    'reason', reason,
    'retries', String(retries),
    'first_seen_ts', new Date().toISOString(),
    'payload', obj.payload ?? '',
  );
}

async function handleEntries(entries: any[]) {
  for (const [id, kv] of entries) {
    const fields = kv as string[];
    try {
      const map: Record<string,string> = {};
      for (let i=0;i<fields.length;i+=2) map[fields[i]] = fields[i+1];
      const { updates } = JSON.parse(map.payload); // 포맷 검증
      // broadcast...
      // ACK after success
      await r.xack(STREAM, GROUP, id);
    } catch (e:any) {
      // 재시도 메타 추출(간단 예: 필드에 'retries' 없으면 0으로)
      const retries = Number((fields.find((v,i)=>v==='retries' && fields[i+1]) && fields[fields.indexOf('retries')+1]) || 0);
      if (retries >= 3) {
        await xaddDLQ(`parse_or_broadcast_error:${e.message}`, { id, fields }, retries);
        await r.xack(STREAM, GROUP, id); // DLQ로 보냈으면 원 메시지는 ACK
      } else {
        // 재시도 마킹(필드 업데이트가 필요하면 XADD 새 메시지 + ACK/DEL 설계 고려)
        await r.xclaim(STREAM, GROUP, CONSUMER, 0, id); // 소유권만 변경
        // 처리 재시도는 다음 루프/XAUTOCLAIM 경로에서 진행
      }
    }
  }
}
2-3) 펜딩 복구 + DLQ 연계
오래된 펜딩(XAUTOCLAIM) → 실패 시 XADD dlq:status로 즉시 이동.

운영 쿼리

bash
복사
편집
# 펜딩 상태 조회
XPENDING status:updates:x gw - + 50
# 그룹/컨슈머 상태
XINFO GROUPS status:updates:x
XINFO CONSUMERS status:updates:x gw
# DLQ 상위 N 확인
XRANGE dlq:status - + COUNT 20
선택: DLQ 재처리용 별도 워커(수동/조건부) 마련. 메시지 복구 시 원본 스트림으로 다시 XADD 후 DLQ 항목 삭제.

3) 라이트/다크 자동 스위칭 인쇄 CSS
목표: 화면은 다크, PDF/프린트는 라이트 또는 OS 테마에 맞춰 자동.
전략: CSS 변수 기반 테마 + @media (prefers-color-scheme: …) 및 @media print 분기.

3-1) 전역 테마 토큰
css
복사
편집
/* globals.css */
:root {
  --bg: #0B1220;        /* dark default */
  --fg: #E6EAF2;
  --card: #0F172A;
  --border: rgba(255,255,255,0.08);
}
@media (prefers-color-scheme: light) {
  :root {
    --bg: #ffffff;      /* light */
    --fg: #0B1220;
    --card: #f8fafc;
    --border: rgba(0,0,0,0.08);
  }
}

/* 프린트는 기본 라이트 권장 */
@media print {
  :root {
    --bg: #ffffff !important;
    --fg: #0B1220 !important;
    --card: #ffffff !important;
    --border: rgba(0,0,0,0.12) !important;
  }
  /* 배경/그라디언트 제거, 박스 라인 보강 */
  body { background: var(--bg) !important; color: var(--fg) !important; }
  .card { background: var(--card) !important; border: 1px solid var(--border) !important; box-shadow: none !important; }
  a { color: #0B57D0 !important; text-decoration: underline !important; }
  /* 페이지 나눔 제어 */
  .avoid-break { page-break-inside: avoid; }
}
3-2) 컴포넌트 적용 예
tsx
복사
편집
// BenchmarkMatrix 컨테이너에 클래스만 주면 자동 스위칭
<div className="card overflow-auto rounded-xl border" style={{
  background: 'var(--card)', borderColor: 'var(--border)', color: 'var(--fg)'
}}>
  {/* ... */}
</div>
3-3) PDF 라우트에서 라이트 강제(옵션)
Puppeteer로 라이트 강제를 원하면, 쿼리 파라미터/클래스로 오버라이드:

tsx
복사
편집
// /app/benchmark/print/page.tsx (라이트 강제 옵션)
export default function PrintPage({ searchParams }: { searchParams: { theme?: string } }) {
  const forceLight = searchParams?.theme === 'light';
  return (
    <div className={forceLight ? 'force-light' : ''} style={{ background: 'var(--bg)', color: 'var(--fg)' }}>
      {/* ... */}
    </div>
  );
}
css
복사
편집
/* globals.css */
.force-light {
  --bg: #ffffff !important;
  --fg: #0B1220 !important;
  --card: #ffffff !important;
  --border: rgba(0,0,0,0.12) !important;
}
Puppeteer:

ts
복사
편집
await page.goto(`${base}/benchmark/print?theme=light`, { waitUntil: 'networkidle2' });
운영 체크리스트
Timescale

add_reorder_policy + add_compression_policy + add_retention_policy 3종 세트 적용.

CAGG는 결과 보존 기간을 더 길게 유지(대시보드용).

jobs/bgw_job_stats로 정책 실행 상태 모니터링.

Streams

DLQ 흐름 확립: 재시도 한도, 원인, 알림(Ops 채널).

XAUTOCLAIM 루프와 DLQ 분류(포맷 오류/타임아웃/브로드캐스트 실패 등) 분리.

Print

한글 PDF 폰트(예: Noto Sans CJK) 포함.

큰 표는 .avoid-break로 행 단위 분리, 헤더 sticky 제거(인쇄 시 겹침 방지).






