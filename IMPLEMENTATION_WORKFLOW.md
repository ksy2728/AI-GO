# AI-GO Implementation Workflow
> üéØ **Î™©Ìëú**: Mock Îç∞Ïù¥ÌÑ∞Î•º Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î°ú Ï†ÑÌôòÌïòÍ≥† ÌîÑÎ°úÎçïÏÖò Ï§ÄÎπÑ ÏôÑÎ£å

## üìä ÌîÑÎ°úÏ†ùÌä∏ ÌòÑÌô©
- **ÏôÑÎ£åÎêú Î∂ÄÎ∂Ñ**: UI/UX (90%), WebSocket (100%), Í∏∞Î≥∏ Ïù∏ÌîÑÎùº (100%)
- **Î™©ÏóÖ ÏÉÅÌÉú**: Î™®Îì† API Îç∞Ïù¥ÌÑ∞ (100% Mock)
- **ÏòàÏÉÅ Í∏∞Í∞Ñ**: 6Ï£º (ÌíÄÌÉÄÏûÑ Í∞úÎ∞ú Í∏∞Ï§Ä)
- **Ïö∞ÏÑ†ÏàúÏúÑ**: Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô ‚Üí API ÌÜµÌï© ‚Üí Í∏∞Îä• Íµ¨ÌòÑ ‚Üí ÏµúÏ†ÅÌôî ‚Üí Î∞∞Ìè¨

---

## üöÄ Phase 1: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ï (Week 1)

### Day 1-2: PostgreSQL & Prisma ÏÑ§Ï†ï
```bash
# 1. PostgreSQL Docker ÏÑ§Ï†ï
docker run --name ai-go-postgres \
  -e POSTGRES_PASSWORD=your_password \
  -e POSTGRES_DB=aigo \
  -p 5432:5432 \
  -d postgres:16-alpine

# 2. Prisma Ïä§ÌÇ§Îßà ÏÉùÏÑ±
npx prisma init
```

#### üìù Ïä§ÌÇ§Îßà Ï†ïÏùò (`prisma/schema.prisma`)
```prisma
model Provider {
  id        String   @id @default(cuid())
  name      String   @unique
  slug      String   @unique
  website   String?
  models    Model[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Model {
  id              String          @id @default(cuid())
  providerId      String
  provider        Provider        @relation(fields: [providerId], references: [id])
  name            String
  slug            String          @unique
  description     String?
  contextWindow   Int?
  maxTokens       Int?
  releasedAt      DateTime?
  isActive        Boolean         @default(true)
  pricing         Json?
  capabilities    String[]
  benchmarks      Benchmark[]
  statusHistory   ModelStatus[]
  incidents       Incident[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model ModelStatus {
  id           String   @id @default(cuid())
  modelId      String
  model        Model    @relation(fields: [modelId], references: [id])
  status       String   // operational, degraded, down
  availability Float
  responseTime Int?     // ms
  timestamp    DateTime @default(now())
  
  @@index([modelId, timestamp])
}

model Benchmark {
  id        String   @id @default(cuid())
  modelId   String
  model     Model    @relation(fields: [modelId], references: [id])
  suite     String   // MMLU, HumanEval, etc.
  score     Float
  metadata  Json?
  testedAt  DateTime
  createdAt DateTime @default(now())
}

model Incident {
  id          String   @id @default(cuid())
  modelId     String
  model       Model    @relation(fields: [modelId], references: [id])
  title       String
  description String?
  severity    String   // critical, major, minor
  status      String   // investigating, identified, monitoring, resolved
  startedAt   DateTime
  resolvedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model News {
  id          String   @id @default(cuid())
  title       String
  content     String
  source      String
  url         String?
  category    String
  tags        String[]
  publishedAt DateTime
  createdAt   DateTime @default(now())
}
```

#### üîß ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ
```bash
# ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏÉùÏÑ± Î∞è Ïã§Ìñâ
npx prisma migrate dev --name init

# Prisma Client ÏÉùÏÑ±
npx prisma generate

# ÏãúÎìú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
npx prisma db seed
```

### Day 3: Redis Ï∫êÏã± ÏÑ§Ï†ï
```typescript
// src/lib/redis.ts
import Redis from 'ioredis'

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  retryStrategy: (times) => Math.min(times * 50, 2000),
})

export const cache = {
  async get<T>(key: string): Promise<T | null> {
    const data = await redis.get(key)
    return data ? JSON.parse(data) : null
  },
  
  async set(key: string, value: any, ttl = 3600): Promise<void> {
    await redis.setex(key, ttl, JSON.stringify(value))
  },
  
  async invalidate(pattern: string): Promise<void> {
    const keys = await redis.keys(pattern)
    if (keys.length) {
      await redis.del(...keys)
    }
  }
}
```

### Day 4-5: Îç∞Ïù¥ÌÑ∞ Ï†ëÍ∑º Î†àÏù¥Ïñ¥ Íµ¨ÌòÑ
```typescript
// src/services/models.service.ts
import { prisma } from '@/lib/prisma'
import { cache } from '@/lib/redis'

export class ModelService {
  static async getAll(filters?: ModelFilters) {
    const cacheKey = `models:${JSON.stringify(filters)}`
    
    // Check cache first
    const cached = await cache.get(cacheKey)
    if (cached) return cached
    
    // Query database
    const models = await prisma.model.findMany({
      where: {
        isActive: filters?.isActive,
        provider: filters?.provider ? {
          slug: filters.provider
        } : undefined,
      },
      include: {
        provider: true,
        statusHistory: {
          take: 1,
          orderBy: { timestamp: 'desc' }
        }
      }
    })
    
    // Cache results
    await cache.set(cacheKey, models, 300) // 5 minutes
    
    return models
  }
  
  static async updateStatus(modelId: string, status: ModelStatusData) {
    const result = await prisma.modelStatus.create({
      data: {
        modelId,
        ...status
      }
    })
    
    // Invalidate related caches
    await cache.invalidate(`models:*`)
    await cache.invalidate(`status:${modelId}`)
    
    return result
  }
}
```

---

## üîå Phase 2: Ïô∏Î∂Ä API ÌÜµÌï© (Week 2)

### Day 6-7: OpenAI API ÌÜµÌï©
```typescript
// src/lib/external-apis/openai.ts
import OpenAI from 'openai'

export class OpenAIMonitor {
  private client: OpenAI
  
  constructor() {
    this.client = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    })
  }
  
  async checkStatus(): Promise<ModelStatusData> {
    try {
      const start = Date.now()
      
      // Test with minimal API call
      await this.client.models.list()
      
      return {
        status: 'operational',
        availability: 100,
        responseTime: Date.now() - start
      }
    } catch (error) {
      return {
        status: 'down',
        availability: 0,
        responseTime: null
      }
    }
  }
  
  async getModels() {
    const models = await this.client.models.list()
    return models.data.map(model => ({
      id: model.id,
      name: model.id,
      provider: 'openai',
      created: new Date(model.created * 1000)
    }))
  }
}
```

### Day 8: Anthropic API ÌÜµÌï©
```typescript
// src/lib/external-apis/anthropic.ts
import Anthropic from '@anthropic-ai/sdk'

export class AnthropicMonitor {
  private client: Anthropic
  
  constructor() {
    this.client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    })
  }
  
  async checkStatus(): Promise<ModelStatusData> {
    try {
      const start = Date.now()
      
      // Health check with minimal request
      await this.client.messages.create({
        model: 'claude-3-haiku-20240307',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'Hi' }]
      })
      
      return {
        status: 'operational',
        availability: 100,
        responseTime: Date.now() - start
      }
    } catch (error) {
      return {
        status: 'down',
        availability: 0,
        responseTime: null
      }
    }
  }
}
```

### Day 9-10: Health Check ÌÅ¨Î°† ÏûëÏóÖ
```typescript
// src/services/health-check.service.ts
import cron from 'node-cron'
import { ModelService } from './models.service'
import { OpenAIMonitor } from '@/lib/external-apis/openai'
import { AnthropicMonitor } from '@/lib/external-apis/anthropic'

export class HealthCheckService {
  private monitors = {
    openai: new OpenAIMonitor(),
    anthropic: new AnthropicMonitor(),
    // Add more monitors
  }
  
  start() {
    // Run every 5 minutes
    cron.schedule('*/5 * * * *', async () => {
      console.log('Running health checks...')
      
      for (const [provider, monitor] of Object.entries(this.monitors)) {
        try {
          const status = await monitor.checkStatus()
          
          // Update database
          await ModelService.updateStatus(provider, status)
          
          // Emit WebSocket update
          io.emit('status:update', {
            provider,
            ...status,
            timestamp: new Date()
          })
        } catch (error) {
          console.error(`Health check failed for ${provider}:`, error)
        }
      }
    })
  }
}
```

---

## üõ†Ô∏è Phase 3: ÌïµÏã¨ Í∏∞Îä• Íµ¨ÌòÑ (Week 3-4)

### Week 3: API ÏóîÎìúÌè¨Ïù∏Ìä∏ Ïã§Ï†ú Íµ¨ÌòÑ

#### Models API Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞
```typescript
// src/app/api/v1/models/route.ts
import { NextResponse } from 'next/server'
import { ModelService } from '@/services/models.service'

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    
    const filters = {
      provider: searchParams.get('provider') || undefined,
      isActive: searchParams.get('isActive') === 'true',
      limit: parseInt(searchParams.get('limit') || '50'),
      offset: parseInt(searchParams.get('offset') || '0')
    }
    
    const models = await ModelService.getAll(filters)
    
    return NextResponse.json({
      models,
      total: models.length,
      timestamp: new Date()
    })
  } catch (error) {
    console.error('Error fetching models:', error)
    return NextResponse.json(
      { error: 'Failed to fetch models' },
      { status: 500 }
    )
  }
}
```

#### Search API Íµ¨ÌòÑ
```typescript
// src/app/api/v1/search/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const query = searchParams.get('q')
  
  if (!query || query.length < 2) {
    return NextResponse.json({ 
      error: 'Query must be at least 2 characters' 
    }, { status: 400 })
  }
  
  const results = await prisma.$transaction([
    // Search models
    prisma.model.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { description: { contains: query, mode: 'insensitive' } }
        ]
      },
      include: { provider: true },
      take: 10
    }),
    
    // Search news
    prisma.news.findMany({
      where: {
        OR: [
          { title: { contains: query, mode: 'insensitive' } },
          { content: { contains: query, mode: 'insensitive' } }
        ]
      },
      take: 10
    })
  ])
  
  return NextResponse.json({
    results: {
      models: results[0],
      news: results[1]
    },
    query,
    timestamp: new Date()
  })
}
```

### Week 4: Ï∂îÍ∞Ä Í∏∞Îä• Íµ¨ÌòÑ

#### Î≤§ÏπòÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
```typescript
// src/services/benchmark.service.ts
export class BenchmarkService {
  static async collectBenchmarks() {
    // Scrape from public benchmark sites
    const sources = [
      'https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard',
      'https://github.com/openai/evals',
      // Add more sources
    ]
    
    for (const source of sources) {
      try {
        // Use Playwright for scraping
        const data = await this.scrapeBenchmarkData(source)
        await this.saveBenchmarks(data)
      } catch (error) {
        console.error(`Failed to scrape ${source}:`, error)
      }
    }
  }
}
```

#### News ÌÅ¨Î°§Îü¨
```typescript
// src/services/news.service.ts
import Parser from 'rss-parser'

export class NewsService {
  private parser = new Parser()
  
  async fetchNews() {
    const feeds = [
      'https://openai.com/blog/rss.xml',
      'https://www.anthropic.com/rss.xml',
      // Add more RSS feeds
    ]
    
    for (const feedUrl of feeds) {
      try {
        const feed = await this.parser.parseURL(feedUrl)
        
        for (const item of feed.items) {
          await prisma.news.upsert({
            where: { url: item.link },
            update: {},
            create: {
              title: item.title,
              content: item.contentSnippet,
              url: item.link,
              source: feed.title,
              publishedAt: new Date(item.pubDate),
              category: 'ai-news'
            }
          })
        }
      } catch (error) {
        console.error(`Failed to fetch ${feedUrl}:`, error)
      }
    }
  }
}
```

---

## üß™ Phase 4: ÌÖåÏä§Ìä∏ Î∞è ÏµúÏ†ÅÌôî (Week 5)

### ÌÜµÌï© ÌÖåÏä§Ìä∏
```typescript
// tests/integration/api.test.ts
describe('API Integration Tests', () => {
  test('GET /api/v1/models returns real data', async () => {
    const response = await fetch('/api/v1/models')
    const data = await response.json()
    
    expect(response.status).toBe(200)
    expect(data.models).toBeInstanceOf(Array)
    expect(data.models[0]).toHaveProperty('id')
    expect(data.models[0]).toHaveProperty('provider')
  })
  
  test('Search API works correctly', async () => {
    const response = await fetch('/api/v1/search?q=gpt')
    const data = await response.json()
    
    expect(response.status).toBe(200)
    expect(data.results).toHaveProperty('models')
    expect(data.results).toHaveProperty('news')
  })
})
```

### ÏÑ±Îä• ÏµúÏ†ÅÌôî
```typescript
// next.config.mjs
export default {
  images: {
    domains: ['cdn.openai.com', 'anthropic.com'],
  },
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['lucide-react', '@radix-ui/*']
  },
  compress: true,
  poweredByHeader: false,
}
```

---

## üö¢ Phase 5: Î∞∞Ìè¨ Ï§ÄÎπÑ (Week 6)

### Production ÌôòÍ≤Ω ÏÑ§Ï†ï
```bash
# 1. ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï
cp .env.local .env.production
# Edit with production values

# 2. ÎπåÎìú ÏµúÏ†ÅÌôî
npm run build

# 3. Docker Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
docker build -t ai-go:latest .

# 4. Ïª®ÌÖåÏù¥ÎÑà Ïã§Ìñâ
docker-compose up -d
```

### Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
```typescript
// src/lib/monitoring.ts
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
})
```

---

## üìä Î≥ëÎ†¨ ÏûëÏóÖ Í∞ÄÎä• Ìï≠Î™©

### ÎèôÏãú ÏßÑÌñâ Í∞ÄÎä• (Different Team Members)
```
Developer 1: Database & Backend
- Prisma Ïä§ÌÇ§Îßà ÏÑ§Ï†ï
- API ÏóîÎìúÌè¨Ïù∏Ìä∏ Íµ¨ÌòÑ
- Health check ÏãúÏä§ÌÖú

Developer 2: External APIs
- OpenAI/Anthropic ÌÜµÌï©
- Î≤§ÏπòÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
- News ÌÅ¨Î°§Îü¨

Developer 3: Frontend & Testing
- UI Ïª¥Ìè¨ÎÑåÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
- Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞
- E2E ÌÖåÏä§Ìä∏ ÏûëÏÑ±
```

---

## ‚úÖ ÏôÑÎ£å Í∏∞Ï§Ä

### Phase Î≥Ñ Í≤ÄÏ¶ù Ìï≠Î™©
- **Phase 1**: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ, ÏãúÎìú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
- **Phase 2**: ÏµúÏÜå 2Í∞ú Ïù¥ÏÉÅ Ïô∏Î∂Ä API Ïó∞Îèô ÏôÑÎ£å
- **Phase 3**: Î™®Îì† Î™©ÏóÖ Îç∞Ïù¥ÌÑ∞ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î°ú Ï†ÑÌôò
- **Phase 4**: ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ 80% Ïù¥ÏÉÅ
- **Phase 5**: Production ÌôòÍ≤Ω Î∞∞Ìè¨ ÏÑ±Í≥µ

### ÏµúÏ¢Ö Î™©Ìëú
- [ ] Ïã§ÏãúÍ∞Ñ AI Î™®Îç∏ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ ÏûëÎèô
- [ ] Í≤ÄÏÉâ Í∏∞Îä• ÏôÑÏ†Ñ Íµ¨ÌòÑ
- [ ] ÏÑ±Îä•: API ÏùëÎãµ <200ms
- [ ] Í∞ÄÏö©ÏÑ±: 99.9% Ïù¥ÏÉÅ
- [ ] ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑ: Lighthouse 90Ï†ê Ïù¥ÏÉÅ

---

## üö® Î¶¨Ïä§ÌÅ¨ Î∞è ÎåÄÏùë Î∞©Ïïà

### Í∏∞Ïà†Ï†Å Î¶¨Ïä§ÌÅ¨
- **Ïô∏Î∂Ä API Ï†úÌïú**: Rate limiting ÎåÄÏùëÏùÑ ÏúÑÌïú Ï∫êÏã± Î∞è ÌÅê ÏãúÏä§ÌÖú
- **Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî**: Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ÏôÄ Ï∫êÏãú Î¨¥Ìö®Ìôî Ï†ÑÎûµ
- **ÏÑ±Îä• Î≥ëÎ™©**: Database indexing Î∞è query optimization

### ÏùºÏ†ï Î¶¨Ïä§ÌÅ¨
- **Buffer Time**: Í∞Å PhaseÏóê 20% Ïó¨Ïú† ÏãúÍ∞Ñ ÌôïÎ≥¥
- **MVP First**: ÌïµÏã¨ Í∏∞Îä• Ïö∞ÏÑ† Íµ¨ÌòÑ ÌõÑ Ï†êÏßÑÏ†Å Í∞úÏÑ†
- **Parallel Work**: Í∞ÄÎä•Ìïú ÏûëÏóÖ Î≥ëÎ†¨ Ï≤òÎ¶¨

---

## üìÖ Îã§Ïùå Îã®Í≥Ñ Ïï°ÏÖò ÏïÑÏù¥ÌÖú

### Ï¶âÏãú ÏãúÏûë (Today)
1. PostgreSQL Docker Ïª®ÌÖåÏù¥ÎÑà Ïã§Ìñâ
2. Prisma Ïä§ÌÇ§Îßà ÏûëÏÑ± Î∞è ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
3. Ï≤´ Î≤àÏß∏ Ïã§Ï†ú API ÏóîÎìúÌè¨Ïù∏Ìä∏ Íµ¨ÌòÑ

### Ïù¥Î≤à Ï£º Î™©Ìëú
- [ ] Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ï ÏôÑÎ£å
- [ ] ÏµúÏÜå 1Í∞ú Ïô∏Î∂Ä API Ïó∞Îèô
- [ ] Mock Îç∞Ïù¥ÌÑ∞ ‚Üí Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Ï†ÑÌôò ÏãúÏûë

### ÎßàÏùºÏä§ÌÜ§
- **Week 2**: Ï≤´ Î≤àÏß∏ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌëúÏãú
- **Week 4**: Î™®Îì† API Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô
- **Week 6**: Production Î∞∞Ìè¨